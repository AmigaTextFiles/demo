<#BEG>
                     xxxxxxx   xxxxxx   xxxxxx xxx  xxxxxx
                     xxx  xxx xxx  xxx xxxxxxx xxx xxxxxxx
                     xxx  xxx xxx  xxx xxx     xxx xxx    
                     xxxxxxx  xxxxxxxx  xxx    xxx xxx    
                     xxx  xxx xxx  xxx    xxx  xxx xxx    
                     xxx  xxx xxx  xxx     xxx xxx xxx    
                     xxx  xxx xxx  xxx xxxxxxx xxx xxxxxxx
                     xxxxxxx  xxx  xxx xxxxxx  xxx  xxxxxx


        . . .  <C1>РУКОВОДСТВО ПРОГРАММИСТА НА ЯЗЫКЕ PureBasic 2.90</C1>  . . .

<C2> Eugene Sobolev aka aGGreSSor (Санкт-Петербург)</C2>
<C2> email: eugene_sobolev@mail.spbnit.ru</C2>


                                  Содержание:

<C2>                        <HREF "#000" alt="ПРЕДИСЛОВИЕ"> </C2>
<C2>                        <HREF "#001" alt="КОМПИЛЯЦИЯ ПРОГРАММ"> </C2>
<C2>                        <HREF "#002" alt="СИНТАКСИС ЯЗЫКА">     </C2>
<C2>                        <HREF "#003" alt="ТИПИЗАЦИЯ ПЕРЕМЕННЫХ"></C2>
                           <HREF "#103" alt="Объявление переменной">
                           <HREF "#004" alt="Типы данных">
                           <HREF "#005" alt="Перечисляемые типы">
<C2>                        <HREF "#006" alt="ОПЕРАТОРЫ"></C2>
                           <HREF "#106" alt="For : Next">
                           <HREF "#007" alt="Gosub : Return">
                           <HREF "#008" alt="FakeReturn">
                           <HREF "#009" alt="If : Else : EndIf">
                           <HREF "#010" alt="Repeat : Until">
                           <HREF "#011" alt="Select : EndSelect">
                           <HREF "#012" alt="FakeEndSelect">
                           <HREF "#013" alt="While : Wend">
                           <HREF "#014" alt="Goto">
<C2>                        <HREF "#015" alt="ПОДКЛЮЧЕНИЕ ФАЙЛОВ"></C2>
                           <HREF "#115" alt="IncludeFile">
                           <HREF "#115" alt="XIncludeFile">
                           <HREF "#016" alt="IncludeBinary">
                           <HREF "#017" alt="IncludePath">
<C2>                        <HREF "#018" alt="ПРЕПРОЦЕССОР КОМПИЛЯТОРА"></C2>
                           <HREF "#118" alt="CompilerIf">
                           <HREF "#019" alt="CompilerSelect">
<C2>                        <HREF "#020" alt="АССЕМБЛЕРНЫЕ ВКЛЮЧЕНИЯ"></C2>


<#000>

                               o  <C1>ПРЕДИСЛОВИЕ</C1>  o

<I><C2>    Компилятор   языка </C2>  PureBasic   2.90 <C2> (</C2><C1>PBCompiler</C1><C2>)  является  превосходным</C2></I>
<I><C2> кросс-платформенным  средством  и  первоначально  ориентировался  авторами  на</C2></I>
<I><C2> написание  </C2>plain<C2>-игр  (платформеров), уровня </C2><C1>Dizzy</C1><C2>, </C2><C1>Breakout</C1><C2>, </C2><C1>Majhong</C1><C2>.  </C2></I>

<I><C2>    Версии   компилятора   существуют   под  </C2><C1>3</C1><C2>  основные  программно-аппаратные</C2></I>
<I><C2> платформы:   </C2><C1>Windows</C1><C2>,  </C2><C1>Linux</C1><C2>  и  </C2><C1>AmigaOS</C1><C2>.   Автору этого руководства, довелось</C2></I>
<I><C2> пользоваться всеми тремя, и поэтому хочется заметить, что версия </C2>PureBasic<C2> для</C2></I>
<I><C1> AmigaOS </C1><C2> менее  функциональна, нежели другие (в основном из-за того, что редко</C2></I>
<I><C2> обновляется   и   отстаёт   от  основной  линии  разработки).   Различаются  и</C2></I>
<I><C2> приоритетность  доступных  средств  языка, и библиотек.  Под </C2><C1>Linux</C1><C2> на </C2>PB<C2> проще</C2></I>
<I><C2> писать  интерфейсы  программ (хотя  это  заслуга  скорее </C2><C1>Linux</C1><C2>, а не </C2>PB<C2>), а не</C2></I>
<I><C2> программировать   графику.    Версия   для  </C2><C1> Windows </C1><C2>  более  удобна  в  плане</C2></I>
<I><C2> программирования  графики,  а  интерфейсная и сетевая части слабо развиты. Под</C2></I>
<I><C1> AmigaOS </C1><C2>средства языка </C2>PureBasic<C2> настолько же уступают своим тёзкам под другие</C2></I>
<I><C2> ОС, насколько, например </C2>BlitzBasic<C2> уступает</C2> AMOS<C2> (вопрос спорный).</C2></I>

<I><C2>    Так  или иначе, язык хорошо развит, и если бы для него существовало </C2><C1>IDE</C1><C2>, то</C2></I>
<I><C2> он вполне бы мог позиционироваться на </C2><C1>Amiga</C1><C2> так же, как </C2>VisualBasic<C2> (</C2>VBA<C2>, </C2>WSH<C2>,</C2></I>
<I><C2> и   т.д.)   позиционируется   на   </C2><C1>PC</C1><C2>.    Препятствием, по  видимому  являются</C2></I>
<I><C2> сравнительная новизна компилятора, отсутствие молодых программистов на </C2><C1>Amiga</C1><C2> и </C2></I>
<I><C2> плохая  документированность.  На русском языке, читатели могли познакомиться с</C2></I>
<I> PureBasic<C2>  в  5-м  номере  журнала,  когда  нами было опубликовано официальное</C2></I>
<I><C2> "Руководство   пользователя"   в   переводе   </C2><C1>MacBuster</C1>^<C1>tPA</C1><C2>.    Сейчас  широко</C2></I>
<I><C2> распространилась  </C2><C1>AmigaGuide</C1><C2>-версия того перевода.  "Руководство программиста"</C2></I>
<I><C2> пришлось  собирать  по  крупицам, из  всех трёх версий - родная </C2><C1>AmigaOS</C1><C2>-версия</C2></I>
<I><C2> оказалась  наиболее  слабо  документированой.  Представленая  здесь компиляция</C2></I>
<I><C2> является  неполной  т.к.   журнал  не  резиновый  и всё что хотелось бы в него</C2></I>
<I><C2> запихнуть, в него - увы, давно уже не лезет. Полные версии обоих руководств, а</C2></I>
<I><C2> также подготавливаемую сейчас документацию по функциям библиотек можно найти и</C2></I>
<I><C2> скачать в </C2>Internet<C2>, на сайте </C2><C1><HREF "#http://amitrans.narod.ru" alt="Русский Транзит"></C1><C2>.</C2></I>

                                                      <I> / Технический редактор /</I>

 <HREF "#BEG" alt=" > "> <B>ВЕРНУТЬСЯ В НАЧАЛО</B>


<#001>

                           o  <C1>КОМПИЛЯЦИЯ ПРОГРАММ</C1>  o
 
<C2>    Командно-строчный   компилятор   можно   найти  в  директории  '</C2>Compilers\<C2>'</C2>
<C2> дистрибутива  </C2><C1>PureBasic</C1><C2>.   Компилятор  </C2><C1>PBCompiler</C1><C2>,  по сути только преобразует</C2>
<C2> файлы  программ  на  языке  </C2><C1>PureBasic</C1><C2>,  в  файлы  программ на языке ассемблера</C2>
 Motorola  68k<C2>, а компиляцией последних, занимается уже ассемблер </C2><C1>PhxAss</C1><C2>.  Этот</C2>
<C2> подход  аналогичен  применённому в компиляторе </C2><C1>PowerD</C1><C2> и позволяет сравнительно</C2>
<C2> легко  поддержать  любую  из  существующих  процессорных линеек.  Для удобства</C2>
<C2> пользования  компилятором,  рекомендуется  скопировать файлы этой директории в</C2>
<C2> '</C2>C:<C2>'  или  прописать  в  файле  '</C2>S:User-Startup<C2>' строчку:  '</C2>Assign C:  "путь к
 директории  Compilers" ADD<C2>'.  Доступные в командной строке аргументы, не имеют</C2>
<C2> ничего  общего  с  версиями  компилятора  </C2><C1>PBCompiler</C1><C2>  для  </C2><C1>Windows</C1><C2>  и </C2><C1>Linux</C1><C2>, и</C2>
<C2> показываются при запуске компилятора.</C2>


 ? <C2>: показывает краткую справку по аргументам компилятора </C2>PBCompiler

 AMIGAOS/S (синоним : OS) <C2>: подключение поддержки библиотек</C2> AmigaOS

 CREATERESIDENT/K (синоним : CR) "имя файла" <C2>: создание резидентного файла</C2>

 DEBUGGER/S (синоним : DB) <C2>: включение встроенного отладчика</C2>

 MC68020/S <C2>: отключение поддержки </C2>FPU <C2>и</C2> MMU

 NOCOMMENT/S (синоним : NC)  <C2>:  отключение   комментирования   в   генерируемых</C2>
                             <C2>         ассемблерных файлах (ускоряет компиляцию)</C2>

 NORESIDENT/S (синоним : NR) <C2>:        отключение поддержки создания резидентных</C2>
                             <C2>                      файлов (ускоряет компиляцию)</C2>

 OPTIMIZATIONS/S (синоним: OPT) <C2>:      включение оптимизации генерируемого кода</C2>
                                <C2>       (замедляет   компиляцию,   но  позволяет</C2>
                                <C2>       получать   исполняемые   файлы  меньшего</C2>
                                <C2>       размера)</C2>

 PRIORITY/K/N  (синоним  :  PRI) "число (-127..127)" <C2>:  устанавливает приоритет</C2>
                                                     <C2>для компилятора PBCompiler</C2>

 TO/K  "путь  и  имя  файла" <C2>:  позволяет указать путь по которому будет создан</C2>
                             <C2>   исполняемый файл</C2>


<C1>  Синтаксис вызова компилятора:</C1>


 PBCompiler <C2><исходный файл></C2> TO <C2><исполняемый файл> <аргументы></C2>


<C1>  Например:</C1>

 1) PBCompiler sourcecode.pb 

<C2> Компилируется файл</C2> 'sourcecode.pb' <C2>и запускается созданный исполняемый файл.</C2>


 2) PBCompiler sourcecode.pb DEBUGGER AMIGAOS PRI=10 

<C2> Компилируется  файл  '</C2>sourcecode.pb<C2>' и запускается созданный исполняемый файл;</C2>
<C2> включены  отладчик  и  поддержка  библиотек  </C2><C1>AmigaOS</C1><C2>,  компилятору  установлен</C2>
<C2> приоритет </C2><C1>10</C1><C2>.</C2>


<C1>  Замечание:</C1>

<C2>    Расположенный  в  директории '</C2>Compilers/<C2>' файл '</C2>Default_Icon.info<C2>' - это та</C2>
<C2> иконка,  которая будет присваиваться исполняемым файлам после компиляции; файл</C2>
<C2> '</C2>Misc.asm<C2>'  -  содержит  макроопределения  </C2>startup<C2>,  аллокации памяти и прочих</C2>
<C2> системных операций (кодеры легко могут оптимизировать их для себя).</C2>

 <HREF "#BEG" alt=" > "> <B>ВЕРНУТЬСЯ В НАЧАЛО</B>


                               .../\  ...^   ...
                                    \/     \/

<#002>

                             o  <C1>СИНТАКСИС ЯЗЫКА</C1>  o

    При  программировании  на  языке  PureBasic необходимо соблюдение следующих
 синтаксических правил :


 - <C2>Комментарии обозначаются символом '</C2><C1> ; </C1><C2>'. </C2>
   <C2>Весь текст следующий после символа '</C2><C1> ; </C1><C2>' будет проигонорирован компилятором. </C2>


<C1> Например:</C1>
 
    If a = 10 ; Это комментарий, как вы могли заметить. 

 - <C2>Все процедуры должны содержать в своём имени символ '</C2><C1> ( </C1><C2'.</C2>
   <C2>В  противном  случае  они  не  будут  распознаны  как процедуры, (включая не</C2>
   <C2>имеющие аргументов). </C2>


<C1> Например: </C1>

    WindowID() ; это функция. 
    WindowID   ; это переменная. 

 - <C2>Все константы должны предваряться символом '</C2><C1> # </C1><C2>'.</C2>


<C1> Например: </C1>

    #Hello = 10 ; это константа. 
    Hello = 10  ; это переменная. 


 - <C2>Все имена меток должны занчиваться символом '</C2><C1> : </C1><C2>'. </C2>

<C1> Например: </C1>

    Я_представляю_собой_метку: 


 - <C2>Вычисляемые  выражения  могут  включать  в  себя  переменные,  константы   и</C2>
   <C2>процедуры в любых возможных сочетаниях.</C2>

<C1> Примеры допустимых выражений:</C1>

    a+1+(12*3) a+WindowHeight()+b/2+#Моя_любимая_константа 
    a <> 12+2 b+2 >= c+3


 - <C2>Для перечисления любого числа операторов в одной строке служит символ ' </C2><C1>: </C1><C2>'. </C2>

<C1> Например:</C1>

  If OpenScreen(0,320,200,8,0) : PrintN("Ok") : Else : PrintN("Failed") : EndIf 


 - <C2>Обозначения используемые в данном руководстве:</C2>

  <переменная>  : объявление переменной. 
  <выражение>   : выражение в виде описанном выше. 
  <константа>   : объявление числовой константы. 
  <метка>       : метка в программе. 
  <определение> : любое определение (например, структура). 


 <HREF "#BEG" alt=" > "> <B>ВЕРНУТЬСЯ В НАЧАЛО</B>



<#003>
<C1>                          o  ТИПИЗАЦИЯ ПЕРЕМЕННЫХ  o</C1>

<#103>

<C1> Объявление переменной </C1>

<C2>    В  языке </C2><C1>PureBasic</C1><C2>, для объявления переменной достаточно указать её имя, и,</C2>
<C2> в  случае  необходимости,  назначаемый  переменной  тип  данных.  Переменные с</C2>
<C2> неопределённым  типом  данным  "подхватываются  на  лету"  и  имеют тип данных</C2>
<C2> зависящий  от  контекста  в  котором  их  пытаются  применить  (</C2><C1>Variant</C1><C2>).  Для</C2>
<C2> объявления  типа  данных  сразу  нескольким переменным используется объявление</C2>
<C2> структуры типов оператором '</C2><C1>DefType</C1><C2>'.</C2>


<C1> Например:</C1>

 a.b  ;  объявляется  переменная  с  именем 'a', типом Byte (.b) 
      ;  и размером в 1 байт.

 c.l = a*d.w ; здесь переменная с именем 'd' объявляется прямо в выражении !


<C2>    Для  объявления  указателя  следует  использовать символ '</C2><C1> * </C1><C2>' перед именем</C2>
<C2> переменной.   Объявленный  указатель  представляет  собой переменную типа</C2><C1> Long</C1>
<C2> содержащую  адрес.   Обычно  указатели  используются  для оперирования данными</C2>
<C2> структур.   Объявлением  указателя  достигается  получение  и изменение данных</C2>
<C2> содержащихся в структуре.</C2>


<C1> Например :</C1>

 *MyScreen.Screen = OpenScreen(0,320,200,8,0) 

 mouseX = *MyScreen\MouseX ; предпологается что структура с именем 'Screen' 
                           ; содержит поле с именем 'MouseX'.


<#004>

<C1> Типы данных </C1>

<C2>    В   языке </C2><C1>  PureBasic</C1><C2>,   допускается  назначение  типа  данных  объявляемой</C2>
<C2> переменной.    Тип   данных  позволяет  указать  характер  данных  хранимых  в</C2>
<C2> переменной,  например:   целое  значение  (</C2><C1>Byte</C1><C2>, </C2><C1> Word</C1><C2>, </C2><C1> Long</C1><C2>), действительное</C2>
<C2> значение  (</C2><C1>Float</C1><C2>) или строка (</C2><C1>String</C1><C2>).  Ниже, можно увидеть таблицу содержащую</C2>
<C2> типы данных допустимые в</C2><C1> PureBasic</C1><C2>, идентификаторы которыми они назначаются, и</C2>
<C2> их описание :</C2>

 ­ЎЎЎЎЎЎЎѕЎЎЎЎЎЎЎЎЎЎЎЎѕЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎѕЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЇ
 ў  Тип  ў Объявление ў Занимаемая память     ў Диапазон                      ў
 ЄЎЎЎЎЎЎЎµЎЎЎЎЎЎЎЎЎЎЎЎµЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎµЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎҐ
 ў<C2>Byte   </C2>ў    .b      ў<C2> 1 байт в памяти       </C2>ў<C2> от -128 до +127               </C2>ў
 ў<C2>Word   </C2>ў    .w      ў<C2> 2 байта в памяти      </C2>ў<C2> от -32768 до +32767           </C2>ў
 ў<C2>Long   </C2>ў    .l      ў<C2> 4 байта в памяти      </C2>ў<C2> от -2147483648 до +2147483647 </C2>ў
 ў<C2>Float  </C2>ў    .f      ў<C2> 4 байта в памяти      </C2>ў<C2> неограничен                   </C2>ў
 ў<C2>String </C2>ў    .s      ў<C2> длина строки + 1 байт </C2>ў<C2> неограничен                   </C2>ў
 ў<C2>Variant</C2>ў    нет     ў<C2> неограничено          </C2>ў<C2> неограничен                   </C2>ў
 їЎЎЎЎЎЎЎ¶ЎЎЎЎЎЎЎЎЎЎЎЎ¶ЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎ¶ЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎґ

<#005>
 
<C1> Перечисляемые типы данных </C1>

<C2>    Для  объявления перечисляемых типов данных используется оператор объявления</C2>
<C2> структуры.  Более подробно этот материал изложен в главе посвящённой оператору</C2>
<C2> '</C2>Structure<C2>', в данном руководстве.</C2>


 <HREF "#BEG" alt=" > "> <B>ВЕРНУТЬСЯ В НАЧАЛО</B>


                               .../\  ...^   ...
                                    \/     \/

<#006>

                                o  <C1>ОПЕРАТОРЫ</C1>  o

<#106>

                                  <C1>For : Next</C1>


<C1> Синтаксис</C1>

  For <переменная> = <выражение1> To <выражение2> [Step <константа>]
                                 . . .
  Next [<переменная>]


<C1> Описание</C1>

<C2>    Операторы   '</C2>For  :   Next<C2>'  служат  для  выполнения  группы  операторов  в</C2>
<C2> безусловном  цикле.  Первая итерация цикла начинается с того, что </C2><переменной>
<C2> присваивается  </C2><выражение1><C2>.   Каждую  последующую  итерацию  цикла,  значение</C2>
 <переменной><C2>  увеличивается на </C2><C1>1</C1><C2> (или на величину "шага" если </C2><константа><C2> была</C2>
<C2> указана  после  оператора  </C2><C1>Step</C1><C2>),  до  тех  пор  пока величина</C2> <переменной><C2> не</C2>
<C2> сравняется с </C2><выражением2><C2>, после чего итерации прекратятся.</C2>


<C1> Пример 1: </C1>

  For k = 0 To 10 
    ...
  Next
    
<C2> Программа выполняет</C2><C1> 11</C1><C2> итераций (от</C2><C1> 0</C1><C2> до</C2><C1> 10</C1><C2>), после чего завершается.</C2>


<C1> Пример 2: </C1>

  a = 2
  b = 3 
  For k = a+2 To b+7 Step 2
    ...
  Next k  

<C2>    Здесь,  прежде  чем завершится, программа выполнит</C2><C1> 4</C1><C2> итерации (переменная </C2><C1>k</C1></C2>
<C2> увеличивается  на  </C2><C1>2</C1><C2>  каждую  итерацию  и  принимает значения:  </C2><C1>4</C1><C2>, </C2><C1>6</C1><C2>,</C2><C1> 8</C1><C2> и </C2><C1>10</C1><C2>).</C2>
<C2> Переменная  "</C2><C1>k</C1><C2>"  после  оператора  "</C2><C1>Next</C1><C2>"  указывает,  что  на  этом операторе</C2>
<C2> заканчивается  тело  цикла  объявленного  в операторе "</C2><C1>For</C1><C2>".  Если бы там была</C2>
<C2> указана другая переменная, компилятор выдал бы сообщение об ошибке.  Это может</C2>
<C2> оказаться   полезным   при  рекурсивном  вычислении  нескольких  выражений  во</C2>
<C2> вложенных циклах.</C2>
 

<C1> Пример 3: </C1>

 For x=0 To 320 
  For y=0 To 200 
       Plot(x,y)
  Next y
 Next x


 <HREF "#BEG" alt=" > "> <B>ВЕРНУТЬСЯ В НАЧАЛО</B>


<#007>
                                <C1>Gosub : Return</C1>

<C1> Синтаксис</C1>

            Gosub МояМетка 
     
  МояМетка: 
                . . .

            Return


<C1> Описание</C1>

<C2>    Оператор </C2><C1>Gosub</C1><C2> является сокращением от английского '</C2>Go to sub routine<C2>', что</C2>
<C2> можно  перевести  на  русский язык, как 'Перейти к подпрограмме'.  Метка после</C2>
<C2> оператора </C2><C1> Gosub </C1><C2>указывает, что исполнение должно быть продолжено с того места</C2>
<C2> в   программе,   где   эта  метка  была  объявлена  (начало  подпрограммы),  и</C2>
<C2> продолжаться   до   тех  пор,  пока  не  встретиться  оператор  </C2><C1>Return</C1><C2>  (конец</C2>
<C2> подпрограммы).   Когда это случится, произойдёт возврат к оператору следующему</C2>
<C2> за  </C2><C1>Gosub</C1><C2>  и  исполнение  программы  будет  продолжено.   Оператор Gosub очень</C2>
<C2> полезен при быстром написании программ с очевидной структурой.</C2>


<C1> Например:</C1>
       
  a = 1
  b = 2
  Gosub Вычисления 
  PrintNumberN(a) 
  End 
       
  Вычисления: 
    a = b*2+a*3+(a+b) 
    a = a+a*a 
  Return 


 <HREF "#BEG" alt=" > "> <B>ВЕРНУТЬСЯ В НАЧАЛО</B>


<#008>
                                  <C1>FakeReturn</C1>

<C1> Синтаксис</C1>

 FakeReturn 


<C1> Описание</C1>

<C2>    Когда  требуется  выполнить  переход  из  подпрограммы в произвольную часть</C2>
<C2> программы,  необходимо  использовать оператор </C2><C1>FakeReturn</C1><C2>, и только после него,</C2>
<C2> использовать   оператор   </C2><C1>Goto</C1><C2>.   Оператор  </C2><C1>FakeReturn</C1><C2>  эмулирует  возврат  из</C2>
<C2> подпрограммы,  не совершая его в действительности.  Если вы этого не сделаете,</C2>
<C2> то  программа  просто  повиснет.  Этот оператор может оказаться полезным, т.к.</C2>
<C2> хорошо  структурированная  программа  не  нуждается  в использовании оператора</C2>
</C1> Goto</C1><C2>.  Но в некоторых случаях приходится пользоваться безусловным переходом, в</C2>
<C2> основном, с целью ускорения процесса написания программы.</C2>


<C1> Например: </C1>
     
  Gosub Подпрограмма1
     
  Подпрограмма1:

    . . .

    If a = 10
      FakeReturn 
      Goto Вычисления
    Endif 
  Return


 <HREF "#BEG" alt=" > "> <B>ВЕРНУТЬСЯ В НАЧАЛО</B>


<#009>
                               <C1>If : Else : EndIf</C1>

<C1> Синтаксис</C1>

  If <выражение> 
   ...
  [Else]
   ...
  EndIf 


<C1> Описание</C1>

<C2>    Условный  оператор  </C2><C1>If</C1><C2> служит для управления порядком выполнения операторов</C2>
<C2> программы.   Следующее  за  оператором  </C2><C1>If</C1> <выражение><C2> играет роль условия, от</C2>
<C2> верности  которого  зависит  порядок.   В  одном  операторе  If  можно указать</C2>
<C2> несколько выражений, разделяя их операторами </C2><C1>And</C1><C2> (</C2><выражение><C2> и</C2> <выражение><C2>) и</C2>
<C1> Or</C1><C2>  (</C2><выражение><C2>  или  </C2><выражение><C2>).   Необязательный оператор </C2><C1>Else</C1><C2> служит для</C2>
<C2> описания  группы  операторов  которые  будут  выполняться,  когда </C2> <выражение>
<C2> окажется  неверным.   Конец  тела  оператора </C2><C1>If</C1><C2> определяется оператором </C2><C1>EndIf</C1><C2>.</C2>
<C2> Для операторов </C2><C1>If</C1><C2> допускается неограниченная вложенность тел.</C2>


<C1> Пример 1:</C1>
     
  If a=10 
    PrintN("a=10")
  Else
    PrintN("a<>10")
  EndIf    

<C1> Пример 2: </C1>

   If a=10 And b>=10 Or c=20 
   If b=15 : PrintN("b=15")
    Else       
     PrintN("Допустимое условие")
   EndIf   
    Else     
     PrintN("Условие нарушено")  
   EndIf  



 <HREF "#BEG" alt=" > "> <B>ВЕРНУТЬСЯ В НАЧАЛО</B>


<#010>
                                <C1>Repeat : Until</C1>

<C1> Синтаксис</C1>


 Repeat

  . . .

 Until <выражение> [или Forever] 


<C1> Описание</C1>

<C2>    В условном цикле '</C2>Repeat :  Until<C2>', итерации будут продолжаться до тех пор,</C2>
<C2> пока  </C2><выражение><C2>  (играющее  роль условия), не будет удовлетворено.  Возможно</C2>
<C2> любое число итераций.  Если необходим "вечный" цикл, то вместо оператора </C2>Until
<C2> используется оператор </C2><C1>Forever</C1><C2>.</C2>


<C1> Например: </C1>

  a=0
  Repeat 
    a=a+1
  Until a>100 

<C2>    Итерации происходят пока величина переменной "</C2><C1>a</C1><C2>" не станет > чем </C2><C1>100</C1><C2>, (цикл</C2>
<C2> инициирует </C2><C1>101</C1><C2> итерацию).</C2>


 <HREF "#BEG" alt=" > "> <B>ВЕРНУТЬСЯ В НАЧАЛО</B>


<#011>

                              <C1>Select : EndSelect</C1>

<C1> Синтаксис</C1>

  Select <выражение1>
    Case <выражение2> 
       . . .
    [Case <выражение3>]
       . . .
    [Default] 
       . . .
  EndSelect 


<C1> Описание</C1>

<C2>    Условный оператор</C2><C1> Select</C1><C2> позволяет выполнять различные группы операторов, в</C2>
<C2> зависимости   от   следующего  за  ним  </C2><выражения1><C2>.   Значение  </C2><выражения1>
<C2> поочерёдно   сравнивается   с   выражениями  следующими  за  операторами </C2><C1> Case</C1>
<C2> (</C2><выражение2><C2>,   </C2><выражение3><C2>,   и   т.д.),  до  тех  пор  пока  не  находится</C2>
<C2> удовлетворяющее  ему  выражение.   Когда  это  происходит,  выполняется группа</C2>
<C2> операторов  соответствующая  такому  выражению.   Если  ни одно из выражений в</C2>
<C2> операторах </C2><C1> Case </C1><C2> не  удовлетворило </C2> <выражение1><C2>,  выполняется тело оператора</C2>
<C1> Default</C1><C2>  (если он указан).  Оператор</C2><C1> Select </C1><C2>наиболее эффективен, когда искомое</C2>
<C2> выражение зависит от одной переменной.</C2>


<C1> Например: </C1>

  a = 2
  Select a
    Case 1
      PrintN("Case a = 1")
    Case 2 
      PrintN("Case a = 2") 
    Case 20 
      PrintN("Case a = 20")
    Default
      PrintN("Без вариантов")
  EndSelect


 <HREF "#BEG" alt=" > "> <B>ВЕРНУТЬСЯ В НАЧАЛО</B>


<#012>
                                 <C1>FakeEndSelect</C1>

<C1> Синтаксис</C1>

  FakeEndSelect 


<C1> Описание</C1>

<C2>    Когда требуется выполнить переход из тела конструкции '</C2>Select :  EndSelect<C2>'</C2>
<C2> в    произвольную    часть   программы,   необходимо   использовать   оператор</C2>
<C1> FakeEndSelect</C1><C2>,  и  только  после  него,  использовать оператор </C2><C1>Goto</C1><C2>.  Оператор</C2>
<C1> FakeEndSelect</C1><C2>  эмулирует  завершение  конструкции  '</C2>Select  :   EndSelect<C2>', не</C2>
<C2> совершая  его  в  действительности.   Если  вы этого не сделаете, то программа</C2>
<C2> просто повиснет.</C2>


<C1> Например: </C1>

  Рекурсия1:
    ... 
    Select a
      Case 10
        ...
      Case 20
        FakeEndSelect
        Goto Рекурсия1 
    EndSelect


 <HREF "#BEG" alt=" > "> <B>ВЕРНУТЬСЯ В НАЧАЛО</B>


<#013>

                                 <C1>While : Wend</C1>

<C1> Синтаксис</C1>

  While <выражение>
        . . .
 Wend


<C1> Описание </C1>

<C2>    В  условном  операторе  '</C2>While :  Wend<C2>', итерации будут продолжаться до тех</C2>
<C2> пор,  пока  </C2><выражение><C2>  (играющее  роль условия), не будет нарушено.  Хороший</C2>
<C2> способ  удержать  в  памяти  особенности этого оператора, это запомнить, что в</C2>
<C2> отличии от '</C2>Repeat :  Until<C2>', программа не войдёт в цикл, если после оператора</C2>
 '</C2>While<C2>'  находится  неудовлетворительное  выражение.   В  то  время  как, цикл</C2>
 '</C2>Repeat   :    Until<C2>'  всегда  выполнится  по  крайней  мере  один  раз  (т.к.</C2>
<C2> проверяемое выражение находится в конце тела цикла).</C2>


<C1> Например:</C1>

  b = 0
  a = 10
  While a = 10 
    b = b+1 
    If b=10 
      a=11 
    Endif 
  Wend 

<C2>    Итерации  происходят  пока  величина  переменной  '</C2><C1>a</C1><C2>'  <>  </C2><C1>10</C1><C2>.   Этот  цикл</C2>
<C2> инициирует</C2><C1> 10 </C1><C2>итераций.</C2>


 <HREF "#BEG" alt=" > "> <B>ВЕРНУТЬСЯ В НАЧАЛО</B>


<#014>
                                     <C1>Goto</C1>

<C1> Синтаксис</C1>

  Goto <метка> 

<C1> Описание</C1>

<C2>    Оператор  </C2><C1>Goto</C1><C2>  служит  для  выполнения  безусловного  перехода  в  область</C2>
<C2> программы  обозначенную  меткой.   Некорректное  использование  оператора</C2><C1> Goto</C1>
<C2> часто  приводит  к зависанию программ, поэтому, хотя его применение допустимо,</C2>
<C2> пользоваться   этой   возможностью   необходимо  предварительно  продумав  все</C2>
<C2> последствия от его применения.</C2>


<C1> Например:</C1>

 Цикл:

  If a=11 
    Goto Выход
  Else
    a=a+1
  EndIf
    Goto Цикл

 Выход: 
    a=a-1


 <HREF "#BEG" alt=" > "> <B>ВЕРНУТЬСЯ В НАЧАЛО</B>


<#015>
                       o  <C1>ПОДКЛЮЧЕНИЕ ВНЕШНИХ ФАЙЛОВ</C1>  o</C1>

<#115>

                                  <C1>IncludeFile</C1>
                                 <C1>XIncludeFile</C1>
<C1> Синтаксис</C1>

  IncludeFile  "имя файла" 
  XIncludeFile "имя файла" 


<C1> Описание</C1>

<C2>    Директива  </C2><C1>IncludeFile</C1><C2>  служит  для  включения  в  текущий текст программы,</C2>
<C2> исходных текстов (программ на языке </C2><C1>PureBasic</C1><C2>) хранящихся во внешних файлах, с</C2>
<C2> момента   своего   объявления.    Обычно   этой  возможностью  пользуются  для</C2>
<C2> подключения   библиотек  пользовательских  процедур.   Директива  </C2><C1>XIncludeFile</C1>
<C2> служит   той  же  самой  цели,  однако,  исключает  возможность  многоразового</C2>
<C2> подключения одинаковых файлов.</C2>


<C1> Например:</C1>

  XInclude "Sources\myfile.pb" ; Этот файл будет подключен однажды.
  XInclude "Sources\myfile.pb" ; И проигнорирован в следующий раз. 
 

 <HREF "#BEG" alt=" > "> <B>ВЕРНУТЬСЯ В НАЧАЛО</B>


<#016>
                                 <C1>IncludeBinary</C1>

<C1> Синтаксис</C1>

  IncludeBinary "имя файла" 


<C1> Описание</C1>

<C2>    Директива</C2><C1>  IncludeBinary </C1><C2> служит  для  включения в текущий текст программы,</C2>
<C2> любого  рода данных хранящихся во внешних файлах, с момента своего объявления.</C2>
<C2> Обычно  этой  возможностью  пользуются  для подключения произвольных структур,</C2>
<C2> текстовых массивов и различных мультимедийных данных.</C2>


<C1> Например:</C1>

  IncludeBinary "Data\map.data" 


 <HREF "#BEG" alt=" > "> <B>ВЕРНУТЬСЯ В НАЧАЛО</B>


<#017>
 
                                  <C1>IncludePath</C1>

<C1> Синтаксис</C1>

  IncludePath "путь" 


<C1> Описание: </C1>

<C2>    Директива</C2><C1>  IncludePath</C1><C2>  служит для указания пути, который будет использован</C2>
<C2> для  поиска  подключаемых  файлов.   Такая  возможность  может оказаться очень</C2>
<C2> полезной,  в  тех  случаях,  когда  имеется  несколько  директорий  содержащих</C2>
<C2> множество файлов, которые необходимо подключить.</C2>


<C1> Например:</C1>

  IncludePath  "Sources\Data"
  IncludeFile  "Sprite.pb"
  XIncludeFile "Music.pb"


 <HREF "#BEG" alt=" > "> <B>ВЕРНУТЬСЯ В НАЧАЛО</B>


                               .../\  ...^   ...
                                    \/     \/


<#018>

                        o  <C1>ПРЕПРОЦЕССОР КОМПИЛЯТОРА</C1>  o

<#118>

                                  <C1>CompilerIf</C1>

<C1> Синтаксис</C1>

  CompilerIf  <выражение>
          . . .

  [CompilerElse]
          . . .

  CompilerEndIf


<C1> Описание</C1>

<C2>    Директива   </C2><C1>CompilerIf</C1><C2>   служит   для  создания  приложений  поддерживающих</C2>
<C2> различные  операционные  системы.   Если  </C2><выражение><C2>  оказывается  верным, то</C2>
<C2> компилируется   код,   включённый  в  тело  конструкции,  в  противном  случае</C2>
<C2> игнорируется.    Таким   образом,   можно   писать  программы  содержащие  код</C2>
<C2> специфичный для различных операционных систем и наиболее оптимально отвечающий</C2>
<C2> особенностям каждой из них.</C2>


<C1> Например:</C1>

 CompilerIf #OS = #Linux

  ; некоторый код специфичный для Linux..

 CompilerEndIf


 <HREF "#BEG" alt=" > "> <B>ВЕРНУТЬСЯ В НАЧАЛО</B>


<#019>
                                <C1>CompilerSelect</C1>

<C1> Синтаксис </C1>

  CompilerSelect  <выражение>
   CompilerCase
        . . .
   [CompilerElse]
        . . .
   [CompilerDefault]
    ...
  CompilerEndSelect


<C1> Описание</C1>

<C2>    Директива  </C2><C1>CompilerSelect</C1><C2>  аналогична конструкции '</C2>Select :  EndSelect<C2>', но</C2>
<C2> служит  для  управления  компиляцией  групп  операторов.   При исполнении этой</C2>
<C2> директивы,  скомпилированы будут только те группы, чьё выражение удовлетворяет</C2>
<C2> выражению  директивы.   Таким  образом,  можно  объединить  в одной директиве,</C2>
<C2> различный  код  зависящий от условий выполнения программы (например, различные</C2>
<C2> операционные   системы).    Разумеется,  контекст  применения  этой  директивы</C2>
<C2> значительно более широк.</C2>


<C1> Например:</C1>

 CompilerSelect #OS
  CompilerCase #AmigaOS
                         ; некоторый код специфичный для AmigaOS
  CompilerCase #Linux    
                         ; некоторый код специфичный для Linux
 CompilerEndSelect


 <HREF "#BEG" alt=" > "> <B>ВЕРНУТЬСЯ В НАЧАЛО</B>


                               .../\  ...^   ...
                                    \/     \/


<#020>
                         o  <C1>АССЕМБЛЕРНЫЕ ВКЛЮЧЕНИЯ</C1>  o

<C2>    Язык </C2><C1>  PureBasic</C1><C2>   позволяет   программисту  использовать  любые  мнемоники</C2>
<C2> ассемблера  линейки</C2>  Motorola  68k  <C2>(поддерживаются  инструкции  </C2><C1>FPU</C1><C2> и</C2><C1> MMU</C1><C2>), в</C2>
<C2> версиях компилятора для AmigaOS, и любые мнемоники </C2>x86<C2> (поддерживаются</C2><C1> FPU one</C1>
<C2> и </C2><C1> MMX</C1><C2>),  в  версиях  компилятора  для </C2><C1> Linux </C1><C2> и </C2><C1> Windows</C1><C2>.  Помимо этого, можно</C2>
<C2> непосредственно  обращаться  к  любым  переменным и указателям из ассемблерных</C2>
<C2> мнемоник.   Синтаксис  ассемблерных  включений  соответствует </C2><C1> PhxAss</C1><C2> в случае</C2>
<C1> AmigaOS</C1><C2>,  и </C2><C1> NAsm</C1><C2>,  в  случае  </C2><C1>Linux</C1><C2> и </C2><C1>Windows</C1><C2>.  Для получения более подробной</C2>
<C2> информации  относительно  синтаксиса,  рекомендуется обратиться к документации</C1>
<C2> поставляемой с названными программами.</C1>


    Вот   несколько   правил,   которым  Вы  должны  следовать,  если  захотите
 воспользоваться ассемблерными включениями:


 1.<C2>   Используемые переменные и указатели, должны быть объявлены в программе до</C2>
   <C2> их использования в мнемониках ассемблера.</C2>

 2.<C2>   При  использовании  меток  в  мнемониках ассемблера, имя адресуемой метки</C2>
   <C2> должно  начинаться  с  символа  '</C2><C1>p</C1><C2>'.   Иначе происходит конфликт внутренних</C2>
   <C2> меток компилятора, с метками, использованными в программе.</C2>


<C1> Например:</C1>

  movea.l pМояМетка,a1

       . . .

  МояМетка:


 3.<C1>   PBCompiler </C1><C2>не отслеживает ошибки допускаемые  в  ассемблерных включениях.</C2>
   <C2> Поэтому, рекомендуется проверять корректность написанного кода  при  помощи</C2>
   <C1> PhxAss </C1><C2>перед его включением в программy.</C2>


<C1> Пример ассемблерного включения: </C1>

  movem.l d0-d7/a0-a6,-a7
  movea.l $4,a6
  moveq.l #39,d0
  lea.l   pExecName,a1
  jsr     -56(a6)
  movem.l +a7,d0-d7/a0-a6


 <HREF "#BEG" alt=" > "> <B>ВЕРНУТЬСЯ В НАЧАЛО</B>


 
<B><C1>                _  _      _  _     _       _  _      _  _  _  _</C1></B>
<B><C1>               (-'(_)(/\)(_'( '   (-)(\/)|(_;(-)  ;  (_(_)(_)'/)</C1></B>



