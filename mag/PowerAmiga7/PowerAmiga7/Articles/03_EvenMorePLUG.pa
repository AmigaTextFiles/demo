<#BEG>


<C2>          ___      __        __</C2>  #.<C2>    ______        ___          </C2><C1> ________</C1>
<C2>         #####     ###b     d##</C2> ###<C2>   ########      #####         </C2><C1> ########</C1>
<C2>        d#####b    ####b   d###</C2> '# <C2>  ##########    d#####b        </C2><C1> ###</C1>
<C2>        ### ###    ###### #####</C2> . .<C2> ####   ####    ### ###        </C2><C1> ###</C1>
<C2>       d##   ##b   ############</C2> ###<C2> ###           d##   ##b       </C2><C1> #######</C1>
<C2>       ###   ###   ### #### ###</C2> ###<C2> ###  ######   ###   ###       </C2><C1> #######</C1>
<C2>      d#########b  ###  ##  ###</C2> ###<C2> ####    ###  d#########b      </C2><C1> ###</C1>
<C2>     d###########b ###      ###</C2> ###<C2>  ########## d###########b     </C2><C1> ########</C1>
<C2>     ####     #### ###      ###</C2> ###<C2>   ########  ####     ####     </C2><C1> ########</C1>


         <C1>. . .  КАК НАПИСАТЬ СВОЙ СОБСТВЕННЫЙ PLUGIN К EVENMORE  . . .</C1>
                           ( EvenMore_plugin-HOWTO )

<C2> Eugene Sobolev aka aGGreSSor (Санкт-Петербург)</C2>
<C2> email: eugene_sobolev@mail.spbnit.ru</C2>

 [ <HREF "#111" alt="1"> ] ОПРЕДЕЛЯЕМСЯ С ЦЕЛЬЮ
 [ <HREF "#222" alt="2"> ] ПРЕДВАРИТЕЛЬНЫЙ СБОР ИНФОРМАЦИИ
 [ <HREF "#333" alt="3"> ] ПРИНЦИПЫ РАБОТЫ РАСШИРЕНИЯ
 [ <HREF "#444" alt="4"> ] СТРУКТУРА РАСШИРЕНИЯ
 [ <HREF "#555" alt="5"> ] СПОСОБЫ ОПРЕДЕЛЕНИЯ ТИПА ДОКУМЕНТА
 [ <HREF "#666" alt="6"> ] ОСНОВНОЙ ЦИКЛ РАСШИРЕНИЯ  
 [ <HREF "#777" alt="7"> ] РЕШЕНИЯ РЯДА УСЛОВНЫХ ПРОБЛЕМ
 [ <HREF "#888" alt="8"> ] ПРОЛЕТАРИИ ВСЕХ СТРАН - ОБЪЕДИНЯЙТЕСЬ!


<#111>

                          <C1>o  ОПРЕДЕЛЯЕМСЯ С ЦЕЛЬЮ  o</C1>

<C2>    Редакции  хочется  надеяться,  что  вводная  в диалект языка E для амиги от</C2>
<C2> MindEngine^tPA  (</C2>AmigaE<C2>,  </C2>CreativE<C2>)  опубликованная  в  шестом  номере  нашего</C2>
<C2> журнала  принесла  свои  плоды  и  число поклонников этого гибкого инструмента</C2>
<C2> возросло.   Кстати,  те,  кто интересуется проектом свободно-распространяемого</C2>
<C2> компилятора  </C2>PowerD<C2>  (унаследовавшего  идеи  заложенные  в  </C2>AmigaE<C2>,  но  более</C2>
<C2> приближенного к синтаксису </C2>C++<C2>) или пробует свои силы в программировании с его</C2>
<C2> помощью,   смогут   найти  в  этом  номере  полное  русскоязычное  руководство</C2>
<C2> подготовленное  Владимиром  Яворским  специально  для нашего журнала.  Также в</C2>
<C2> шестом номере можно было прочесть описание диспетчера документов (или попросту</C2>
<C2> говоря,   просмотрщика)   EvenMore   0.60  целиком  написанного  на  </C2>AmigaE<C2>  и</C2>
<C2> являющегося  на  данный  момент  самой развитой программой такого рода за счёт</C2>
<C2> поддержки  внешних расширений (</C2>plugin<C2>'ов).  Приложение шестого номера включало</C2>
<C2> в себя также, полную локализацию, русскоязычную документацию и </C2>powerart.plugin
<C2> позволяющий  просматривать  статьи  нашего  журнала  с  помощью этой программы</C2>
<C2> (сейчас  доступна новая версия 1.02, оптимизированная и избавленная от глюка с</C2>
<C2> "забыванием"  основного цвета текста после ссылок). Таким образом, мы освежили</C2>
<C2> вашу  память.  А сейчас я поведу речь о том, что осталось "за кадром" в шестом</C2>
<C2> номере - о том, как написать свой собственный </C2>plugin<C2> для EvenMore.</C2>

<C2>    Определиться  с  выбором  направления  работы  нашего  будущего  расширения</C2>
<C2> несложно.  Так  уж повелось на нашей платформе, что, сколько бы не выпускалось</C2>
<C2> авторами разнообразных SDK, документации  и  открытых  исходников  (навскидку:</C2>
 EvenMore  SDK<C2>,</C2> AMPlifier SDK<C2>,</C2> Voyager SDK<C2>,</C2> ShapeShifter SDK<C2>,</C2> AOS3.9 SDK <C2>(</C2>NDK<C2>),</C2>
 AWeb  source<C2>,</C2>  WordWorth  source<C2>,  etc),  сколько  бы не писалось статей, и не</C2>
<C2> молилось на каждом углу о помощи в поддержке своих продуктов, всё одно - никто</C2>
<C2> не  пошевельнёт  и  пальцем.   Не пошевельнёт даже если целыми днями находится</C2>
<C2> дома,  коротая  часы  в  высоконравственном  созерцании пупка и размышлениях о</C2>
<C2> своей  роли  в  судьбе  человечества (возможно в этом и есть великий сермяжный</C2>
<C2> смысл   жизни,  но,  к  сожалению,  редакция  не  имеет  времени  на  подобные</C2>
<C2> развлечения).   Так  что  написание  статей  подобных  этой  -  занятие крайне</C2>
<C2> неблагодарное.   Почему так?  Самым распространённым фанбойским ответом будет:</C2>
<C2> "А  потому  что  на  Амиге и так давно есть все, что мне нужно!".  Позвольте с</C2>
<C2> вами  не  согласиться,  скажет  Дмитрий  Гжибовский  и  покажет PC...  Давайте</C2>
<C2> постараемся  и  мы  не  закрывать  глаза  и  присмотреться к альтернативным по</C2>
<C2> отношению к нашей платформам.</C2>

<C2>    Вот скажем, где вы в последний раз на Амиге видели </C2>highlighting<C2> (подсветку)</C2>
<C2> исходников, сценариев  и прочей программистской лабуды? В </C2>GoldED<C2>?  И... </C2>ProgED
<C2> скажет  кто-то,  пошаркает ножкой и промямлит:  "Но там только теги</C2> AmigaGuide
<C2> поддерживаются".  "Зато у нас самые быстрые просмотрщики текстов, их много и в</C2>
<C2> большинстве своём они одно-фреймовые, а все, потому что амижный чипсет rulez!"</C2>
<C2> -  это  еще один голос из-за спины.  Гм...  С поддержкой </C2>ANSI styles<C2>, в лучшем</C2>
<C2> случае  в четыре цвета, а если полагающиеся согласно тому же </C2>ANSI<C2> шестнадцать,</C2>
<C2> то это ой, какая вешалка и коматоз?  А что делать?</C2>

<C2>    А по-хорошему надо с одной стороны зарабатывать деньги на жизнь, а с другой</C2>
<C2> поддержать  подсветку  всех  популярных  языков по всем основным направлениям.</C2>
<C2> Включая те, которые на Амиге не реализованы (согласитесь переписывать что-то с</C2>
<C2> того  же  </C2>Delphi<C2>/</C2>KyLix<C2>  удобнее,  если текст подсвечен, а там глядишь и до нас</C2>
<C2> прогресс докатится?  Хорошо-хорошо, это тебе не надо, но какое ты имеешь право</C2>
<C2> говорить за всех?). Во первых, бедная наша недоразвитая система имеет datatype</C2>
<C2> только для </C2>C<C2>/</C2>C++<C2> (О, эти </C2>datatypes<C2>!  Это же становится доступно сразу и везде!</C2>
<C2> =).  Во  вторых, имеется замечательная программка EvenMore. В третьих, хочется</C2>
<C2> поддержку  большего  числа  языков  в  GoldED  (как  новом,  так и старом).  В</C2>
<C2> четвёртых,  если  вы  так  любите  свой  OPUS  Magellan...   Ну, хотя бы такой</C2>
<C2> наборчик:   </C2>C<C2>/</C2>C++<C2>,  </C2>Rexx<C2>/</C2>Regina<C2>,  </C2>E<C2>/</C2>PowerD<C2>,  </C2>FORTH<C2>, </C2>Pascal<C2>, </C2>PureBASIC<C2>, </C2>Python<C2>,</C2>
 Perl<C2>, </C2>JAVA<C2>.  АГА!  Мы уже определились с целью и можно приступать к следующему</C2>
<C2> этапу - сбору информации.</C2>


 <HREF "#BEG" alt=" > "> <B>ВЕРНУТЬСЯ В НАЧАЛО</B>


                               .../\  ...^   ...
                                    \/     \/


<#222>

                   <C1>o  ПРЕДВАРИТЕЛЬНЫЙ СБОР ИНФОРМАЦИИ  o</C1>

<C2>    Предположим   мы  собрались  бы  написать  поддержку  подсветки  синтаксиса</C2>
<C2> замечательного  языка логического программирования </C2>Prolog<C2>.  Но здесь возникает</C2>
<C2> одна заминка -  мы не знаем этого языка, поскольку на Амиге он, к сожалению не</C2>
<C2> получил большого развития, следовательно, не знаем и его синтаксиса.  Мы можем</C2>
<C2> пойти  двумя  путями - прочитать документацию о </C2>Prolog<C2> с точки зрения человека</C2>
<C2> интересующегося      только     синтаксисом     и     взглянуть     на     его</C2>
<C2> компиляторы/интерпретаторы     (<C2>BProlog</C2>/<C2>SBProlog</C2>,<C2>UNSWProlog</C2>,<C2>TinyProlog</C2>)    или</C2>
<C2> поставить  его  во  вторую  очередь  (пока поумнеем) и переключиться на что-то</C2>
<C2> более повседневное  и  тоже  не  избалованное поддержкой.  Например, на C/С++.</C2>
<C2> Берём любой  справочник по "сям" и, открывая его в части, где рассказывается о</C2>
<C2> ключевых словах языка программирования, которые нельзя использовать в качестве</C2>
<C2> переменных  (это  вообще  характерная  часть,  с которой  начинается  описание</C2>
<C2> большинства языков).  Читаем:</C2>

    <I>"Ключевыми словами стандарта ANSI языка C являются:</I>

                   auto      double  int       struct  
                   break     else    long      switch  
                   case      enum    register  typedef 
                   char      extern  return    union   
                   const     float   short     unsigned
                   continue  for     signed    void    
                   default   goto    sizeof    volatile
                   do        if      static    while    

    <I>Язык C++ в дополнение к ключевым словам языка С добавляет ещё несколько:</I>

           asm       catch    class      friend  inline    new 
           operator  private  protected  public  template  this
           throw     try      virtual".

<C2>    Кроме того, нам конечно  известно,  что большинство   продвинутых   средств</C2>
<C2> программирования  позволяют передавать параметры (аргументы, макроопределения)</C2>
<C2> компилятору  не  только  "снаружи",  но  и  "изнутри",  прямо в тексте (обычно</C2>
<C2> в заголовке) программы. Разбирается с такими инструкциями (их принято называть</C2>
<C2> директивами)   специальная   часть  компилятора,   именуемая  в  простонародье</C2>
<C2> "препроцессором" (</C2>Pre-Processor<C2>). Поддержим и его:</C2>

<I>    "Препроцессор  языка  C  просматривает  программу  до компилятора, заменяет</I>
<I> аббревиатуры   (<B>alias</B>)   в  тексте  программы  на  соответствующие  директивы,</I>
<I> отыскивает  и  присоединяет  к  программе  необходимые  файлы, может влиять на</I>
<I> условия  компиляции.  В действительности препроцессор не является частью языка</I>
<I> C,  но  обычно  включает  в  себя  помимо  собственных  следующие  стандартные</I>
<I> директивы:</I>

                             #define   #elif  
                             #undef    #endif  
                             #include  #line  
                             #if       #error 
                             #ifdef    #pragma
                             #ifndef   #".
                             #else

<C2>    Теперь   нам   необходимо   решить   другой   вопрос:  а как  мы  реализуем</C2>
<C2> цветовыделение, утолщение, курсив, подчёркивание, словом все те стили, которые</C2>
<C2> нам  будет  необходимо  отображать?   И здесь нам придут на помощь ANSI-стили,</C2>
<C2> которые  на  Амиге  худо-бедно  поддержаны  (в том числе в CLI, и что особенно</C2>
<C2> важно  в  нашем  с  вами  случае - в EvenMore).  ANSI-стили могут объявляться,</C2>
<C2> сочетаться   между   собой   (например,  утолщение  +  голубой  цвет  текста),</C2>
<C2> отключаться  (сразу  все)  и  основаны  на  применении  кода Escape в качестве</C2>
<C2> спецсимвола   и   идущими   следом   за   ним  символа  "["  (для  обеспечения</C2>
<C2> идентичности),   а   также  порядкового  номера  спецсимвола.   На  завершение</C2>
<C2> объявления  ANSI-стиля  указывает малая латинская буква "m".  Код Escape можно</C2>
<C2> вводить  нажатием  клавиши  </C2>Esc<C2>  в  </C2>CED<C2>  (при  условии  правильно  настроенной</C2>
<C2> раскладки клавиатуры и наличия галочки в </C2>View/White spaces/Esc code visible?<C2>),</C2>
<C2> а  также  в  языке  </C2>E<C2>  ему  соответствует лексема "</C2>\e<C2>".  Посмотрим на табличку</C2>
<C2> наиболее наиболее популярных ANSI-стилей:</C2>

  \e[0m  - SPECIAL OFF-CODE  <C2>(выключение всех стилей)</C2>
  \e2m   - SPECIAL LIGHT    <C2>(повышение яркости текущих фона и тона)</C2>
  \e7m   - SPECIAL NEGATIVE <C2>(инверсия текущих фона и тона)</C2>

  \e[1m  - BOLD      <C2>(утолщение)</C2>
  \e[3m  - ITALICIZE <C2>(курсив)</C2>
  \e[4m  - UNDERLINE <C2>(подчёркивание)</C2>

  \e[32m - WHITE INC   <C2>(белый тон)</C2>
  \e[33m - BLUE INC    <C2>(синий тон)</C2>
  ...

  \e[42m - WHITE PAPER <C2>(белый фон)</C2>
  \e[43m - BLUE PAPER  <C2>(синий фон)</C2>
  ...

<C2>    Специальные  (</C2>SPECIAL<C2>)  ANSI-стили  не имеют на Амиге полноценной поддержки</C2>
<C2> (за  исключением  </C2>OFF-CODE<C2> =).  Я намерено не дал кодов для других цветов т.к.</C2>
<C2> вся  амижная  поддержка  ANSI  завязана  на  палитру,  а программист не вправе</C2>
<C2> считать,  что  те  же  цвета,  которые настроены в </C2>Palette Prefs<C2> у него, будут</C2>
<C2> такими   же   и  у  пользователя  программы.   И  тем  более  что  они  будут</C2>
<C2> соответствовать  ANSI-стандарту.   Попытка  стандартизации  первых 8-ми цветов</C2>
<C2> (</C2>MagicWB<C2>)  не  дала  результатов,  потому что ныне у нас уже другие стандарты.</C2>
<C2> Поэтому,  вы  можете пользоваться либо только первыми 4-мя цветами "для всех",</C2>
<C2> либо только первыми 16-ю цветами "для пользователей </C2>AOS3.5<C2>/</C2>3.9<C2>".  Естественно,</C2>
<C2> что  в  последнем случае контингент недовольных имеющих "более другую" палитру</C2>
<C2> значительно  увеличивается и чтобы его уменьшить от вас потребуется определять</C2>
<C2> версию предустановленной операционки с далеко идущими выводами.</C2>

<C2>    К  слову,  статья  эта  писалась  за  три  подхода  и  за  это время утекло</C2>
<C2> порядочное  количество  воды.   В  частности,  за  это  время engine программы</C2>
<C2> EvenMore  претерпел  значительные изменения, и в нём (начиная с EvenMore 0.60)</C2>
<C2> появился  механизм поддержки цветовой схемы.  В принципе, о поддержке цветовой</C2>
<C2> схемы программист должен позаботиться сам, но теперь в его руках появились все</C2>
<C2> необходимые  для этого средства.  Алгоритм поддержки можно вытащить, например,</C2>
<C2> из  исходников  расширения </C2>html2text.plugin<C2> (</C2>converthtml5.e<C2>).  Для тех же кому</C2>
<C2> лень это сделать самостоятельно, я приведу ещё одну таблицу:</C2>

  \e50;0;0;0m       <C2>- Чёрный тон      </C2>\e51;0;0;0m      <C2>- Чёрный фон</C2>
  \e50;0;0;255m     <C2>- Синий тон       </C2>\e51;0;0;255m    <C2>- Синий фон</C2>
  \e50;255;0;0m     <C2>- Красный тон     </C2>\e51;255;0;0m    <C2>- Красный фон</C2>
  \e50;255;0;255m   <C2>- Фиолетовый тон  </C2>\e51;255;0;255m  <C2>- Фиолетовый фон</C2>
  \e50;0;255;0m     <C2>- Зелёный тон     </C2>\e51;0;255;0m    <C2>- Зелёный фон</C2>
  \e50;0;255;255m   <C2>- Голубой тон     </C2>\e51;0;255;255m  <C2>- Голубой фон</C2>
  \e50;255;255;0m   <C2>- Жёлтый тон      </C2>\e51;255;255;0m  <C2>- Жёлтый фон</C2>
  \e50;255;255;255m <C2>- Белый тон       </C2>\e51;255;255;255 <C2>- Белый фон</C2>

<C2>    Как  могли  заметить самые прозорливые, код </C2>50<C2> отвечает за цвет тона, а код</C2>
 51  <C2>за  цвет  фона.   Это  идёт  вразрез  с  ANSI-стандартом, но позволяет нам</C2>
<C2> расцвечивать текст, как только мы того захотим.  За соответствующим кодом идут</C2>
<C2> три  компоненты  (</C2>R<C2>,</C2>G<C2>,</C2>B<C2>)  образующие  в  сумме  цвет.  В приведённой таблице я</C2>
<C2> оперирую минимумом(</C2>0<C2>)/максимумом(</C2>255<C2>) для значений компонент.  Это сделано для</C2>
<C2> того,   чтобы   однозначно   задавать  цвет  (коль  скоро,  мы  отказались  от</C2>
<C2> самостоятельного  перевода  палитры в своём расширении).  Поэтому, приведённая</C2>
<C2> таблица строго рекомендована к использованию.  Если же вам не хватает цветов -</C2>
<C2> воспользуйтесь упомянутым алгоритмом для более "тонкой" настройки.</C2>

<C2>    После  того  как  мы  определись  с  ответом на вопрос:  "Как?", появляется</C2>
<C2> необходимость  ответов  на  вопросы  "Что?"  и "Чем?".  Другими словами, какие</C2>
<C2> инструкции языка, каким стилем/сочетанием стилей подсвечивать. Когда возникает</C2>
<C2> такой  вопрос,  лучше  всего поискать ориентир на родной или альтернативных ей</C2>
<C2> платформе.   Для нас таким ориентиром станет </C2>SYS:Classes/DataTypes/C.datatype<C2>.</C2>
<C2> Согласно  этому ориентиру, при парсинге (</C2>parsing<C2> - разбор чего-либо, к примеру</C2>
<C2> исходных текстов программ) выделяются следующие группы ключевых слов:</C2>

<C1>    ГРУППА:                 ПОДСВЕТКА:</C1>

<C2>  Число                   </C2>BOLD BLUE<C2> число</C2> OFF-CODE
<C2>  Комментарий             </C2>ITALICIZE<C2> слово комментарий</C2> OFF-CODE
<C2>  Препроцессор            </C2>BOLD ITALICIZE<C2> слово</C2> OFF-CODE
<C2>  Класс памяти            </C2>UNDER<C2> слово</C2> OFF-CODE
<C2>  Заголовок               </C2>BOLD<C2> слово</C2> OFF-CODE WHITE INC<C2> наименование</C2> OFF-CODE
<C2>  Условия, циклы, etc..   </C2>BOLD WHITE<C2> слово</C2> OFF-CODE

<C2>    Все остальное просто показывается "As Is" - как есть. Однако, здесь имеется</C2>
<C2> несколько  тонкостей.   Например, символ "</C2>*<C2>" всегда утолщён (</C2>BOLD * OFF-CODE<C2>),</C2>
<C2> блочный  комментарий  вида  </C2>/*  */<C2>  содержит целых два различных слова ("</C2>/*<C2>" и</C2>
<C2> "</C2>*/<C2>"),  которые  к тому же могут располагаться в разных строках.  Надо сказать</C2>
<C2> что это уже проблема - любое  объявление  ANSI-стиля действует только до конца</C2>
<C2> строки,   в   которой  оно  объявлено  (более  позднее  замечание:   начиная с</C2>
<C2> EvenMore   0.60   этой   проблемы  не  стало).   Если  после  ключевого  слова</C2>
<C2> препроцессора  идет  указание  на что-либо внешнее (файл, "сишный" заголовок и</C2>
<C2> т.д.), то оно берётся либо в скобки вида "<>", либо в кавычки и выделяется как</C2>
 ITALICIZE  BLUE<C2>  содержимое  </C2>OFF-CODE<C2>.   И  наконец,  при объявлении объекта с</C2>
<C2> классом  памяти </C2>static<C2>, ключевое слово подчеркивается, только если следом идёт</C2>
<C2> символ  "{"  (обозначающий  начало  объектного  блока).   Всё  это  неизбежные</C2>
<C2> проблемы, решение  которых мы отложим на потом, когда разберёмся с оформлением</C2>
<C2> нашего расширения. А пока просто будем помнить, что они есть.</C2>

<C2>    Удивительное  рядом  -  больше   нам  не  требуется ничего знать  и  с этим</C2>
<C2> небольшим   багажом   знаний  мы  приступаем  к  разбору  принципов  написания</C2>
<C2> расширений для EvenMore.  Мало того. Мы можем вообще не знать </C2>C<C2>/</C2>C++<C2>, поддержку</C2>
<C2> которого  собрались  писать,  а  также  не  знать E на котором будем её писать</C2>
<C2> (выучим по ходу пьесы) и ко всему прочему не иметь  никакого  представления об</C2>
<C2> объектно-ориентированном  программировании  (обучение  ООП  в  условиях</C2> AmigaE
<C2> происходит  легко  и  незаметно для обучаемого, в отличии от того же С++ и тем</C2>
<C2> более   </C2>ObjectPascal<C2>).    Важно   только,   чтобы   хоть   с  каким-то  языком</C2>
<C2> программирования  вы  были  бы  хоть  когда-то  знакомы.   Хотя бы с диалектом</C2>
 OxfordBASIC<C2> прошитым в ПЗУ компьютера</C2> Sinclair ZX-Spectrum<C2>. =)</C2>


 <HREF "#BEG" alt=" > "> <B>ВЕРНУТЬСЯ В НАЧАЛО</B>


                               .../\  ...^   ...
                                    \/     \/


<#333>

                       <C1>o  ПРИНЦИПЫ РАБОТЫ РАСШИРЕНИЯ  o</C1>

<C2>    Итак,  каким  же  образом  программа  EvenMore  взаимодействует  со  своими</C2>
<C2> расширениями?   Каждое  расширение  отвечает  за  поддержку отображения своего</C2>
<C2> собственного  типа  файлов.   Следовательно, перед тем как показать документ в</C2>
<C2> каком-либо  хитром  формате сидящему перед компьютером пользователю, программа</C2>
<C2> EvenMore  опрашивает  свои  расширения  с  целью  узнать,  какое  из них может</C2>
<C2> переработать  этот  документ  в  обычный  читаемый текст.  Сама EvenMore умеет</C2>
<C2> отображать  только  обычные  текстовые  файлы  и  плюс  к  этому  поддерживает</C2>
<C2> ANSI-стили  (о  которых  речь  велась  выше).   Задача  номер  один для любого</C2>
<C2> расширения  - определить может оно "переварить" подсовываемый ему документ или</C2>
<C2> нет.   Если  расширение  ответит,  что  "нет,  я  не могу это сделать" (</C2>RETURN
 FALSE<C2>),  то  EvenMore обратится за помощью к другому расширению, затем к более</C2>
<C2> другому,  до  тех пор, пока не переберёт весь список доступных ему расширений.</C2>
<C2> Если ни одно расширение не вызвалось добровольцем, то в зависимости от наличия</C2>
<C2> или  отсутствия  в  первых  нескольких  байтах обрабатываемого документа кодов</C2>
<C2> символов  "выпадающих"  из  диапазона</C2>  $20-$ff<C2>,  будет либо вызвано расширение</C2>
 generic2text.plugin<C2>  (которое  его  в  большинстве  случаев  изуродует),  либо</C2>
<C2> документ  будет показан "As Is" (в виде галиматьи в окне).  Соответственно чем</C2>
<C2> больше расширений способных разбираться с различными типами файлов, тем больше</C2>
<C2> сможет показать EvenMore, и тем веселей, живётся её пользователям.</C2>

<C2>    Определение  типа  "подсовываемого" файла документа может происходить двумя</C2>
<C2> способами:   по  его  имени файла (расширению) или по его сигнатуре (байту или</C2>
<C2> группе  байт  в  теле  файла  документа  идентичных для всех документов одного</C2>
<C2> типа).   Например, если со смещением в 8 байт от начала файла находится строка</C2>
<C2> символов "</C2>WOWO<C2>",  то  расширение имеет дело с документом от</C2> WordWorth<C2>, - это и</C2>
<C2> есть определение по сигнатуре.</C2>

<C2>    Помимо     этого    расширение    (являющееся    по    сути    обыкновенной</C2>
<C2> библиотекой,  исполняющей роль конвертора и отзывающейся на команду </C2>C:Version<C2>)</C2>
<C2> по   первому  требованию  EvenMore,  передаёт  программе  произвольную  строку</C2>
<C2> символов  содержащую  название  и  номер версии.  Для решения каждой задачи из</C2>
<C2> описанных  выше, EvenMore  использует  вызовы специальных функций расширения с</C2>
<C2> заранее  известными  программе  именами.   Чтобы  эти  функции стало возможным</C2>
<C2> вызывать  из  программы,  расширение  компилируется как библиотека и далее всё</C2>
<C2> общение  с  ним  происходит с использованием того же механизма вызова функций,</C2>
<C2> что   и   с  любой  другой  AmigaOS-библиотекой  лежащей  в  директории </C2> LIBS:
<C2> (</C2>OpenLibrary()<C2>,  </C2>CloseLibrary()<C2>,  etc).   В аргументах этих функций передаются</C2>
<C2> данные  необходимые  для  работы  расширения,  а  в  результатах  возвращаемых</C2>
<C2> функциями расширения  -  данные,  по  которым  EvenMore может судить о степени</C2>
<C2> успешности  их  исполнения.  Для облегчения управления со всем этим хозяйством</C2>
<C2> существует  специальный  объект  em_pluginobj  (вот мы  и  добрались до ООП =)</C2>
<C2> вынесенный   в  отдельный  модуль  </C2>epo.m<C2>  (EvenMore  Plugin  Object),  который</C2>
<C2> подгружается  и  присоединяется к каждому расширению на этапе его компиляции и</C2>
<C2> активно  используется  стандартными  функциями  расширения.   Чтобы  уважаемый</C2>
<C2> читатель  не   пугался   слова  "объект",  скажу,  что  сия  странная  материя</C2>
<C2> представляет   из   себя   обыкновенную   табличку  в  виде  нетипизированного</C2>
<C2> одномерного  массива,  элементы которого содержат:  имя файла документа, адрес</C2>
<C2> буфера1  в  памяти  (принято  говорить:   указатель на буфер1), длину буфера1,</C2>
<C2> адрес  буфера2  в  памяти,  длину  буфера2  и могут произвольно изменяться как</C2>
<C2> программой, так и её расширениями.</C2>

    Сам объект em_pluginobj описывается в модуле "epo.m" следующим образом:


 /* Опции препроцессора AmigaE:  скомпилировать модуль (файл с именем исходного
    и   расширением ".m"),   компилировать  под  KickStart 2.04  (по  умолчанию
    компилируется  под  1.02),  количество  регистров  процессора которое может
    использовать  скомпилированная  программа  (влияет  на  размер  получаемого
    экзешника, по умолчанию это 2 регистра - большой экзешник).
 */

 OPT MODULE, OSVERSION = 37, REG = 5

  -> Область видимости объекта em_pluginobj - доступен снаружи (везде)

 EXPORT OBJECT em_pluginobj

   filename              -> Имя файла документа

   buffer:PTR TO CHAR    -> Указатель на данные документа в памяти
   length:LONG           -> Длина данных документа (равен размеру файла),
                         -> значение типа LONG (32-х битное)

   nbuffer:PTR TO CHAR   -> Указатель на конвертированные расширением данные
   nlength:LONG          -> Длина конвертированных данных документа
                         -> значение типа LONG (32-х битное)
 ENDOBJECT


<C2>    О  каких  буферах  идёт речь?  Дело в том, что прежде чем принять решение о</C2>
<C2> том, что делать с полученным файлом документа, EvenMore сначала загружает его,</C2>
<C2> заполняет  соответствующие  элементы  массива  (извините,  объекта =) и только</C2>
<C2> после  этого  начинает  опрос  расширений.   Когда  расширение определяет, что</C2>
<C2> документ  предъявленного типа ему подходит, оно смотрит на размер загруженного</C2>
<C2> файла  и  просит  у EvenMore, во первых выделить ему буфер подходящего размера</C2>
<C2> (для нашей задачи уместен исходный размер, помноженный на 3 - ANSI-стили могут</C2>
<C2> троекратно раздуть размер исходного документа), а во вторых по какому адресу в</C2>
<C2> памяти  этот  буфер расположен.  Если под тот или иной буфер не хватит памяти,</C2>
<C2> сказать  об  этом  пользователю  - проблема EvenMore.  Сама программа EvenMore</C2>
<C2> разумеется,  в свою очередь просит память у системы и получает отказы в случае</C2>
<C2> её  нехватки.   Освобождение  использованной  памяти также не является заботой</C2>
<C2> расширений  (за  исключением  возвращения  правильных  данных  на выходе из их</C2>
<C2> функций).</C2>


 <HREF "#BEG" alt=" > "> <B>ВЕРНУТЬСЯ В НАЧАЛО</B>


                               .../\  ...^   ...
                                    \/     \/


<#444>

                          <C1>o  СТРУКТУРА РАСШИРЕНИЯ  o</C1>


  -> Функция определяет, может ли расширение обработать предъявленный документ.

 /*
    Вход:  имя файла документа или указатель на его положение в памяти.
    Выход: FALSE/TRUE в зависимости от вынесенного решения.
 */

 PROC em_isdatatype(name)   -> или PROC em_isdatatype(memadr)

  RETURN TRUE               -> или RETURN FALSE

 ENDPROC


  -> Функция конвертирует данные файла документа из буфера1 в буфер2.

 /*
    Вход:  указатель на табличку с данными необходимыми для конвертации.
    Выход: указатель  на  буфер2  содержащий  конвертированный текст и значение
           количества сконвертированных байт.
 */

 PROC em_parsedata(epo:PTR TO em_pluginobj)

 ENDPROC mem2, count2
  

 /*
   Функция которую EvenMore вызывает для каждого расширения при опросе, а она в
   свою  очередь  вызывает  em_isdatatype() и другие функции, если это окажется
   необходимым.
 */

 /*
    Вход:  указатель на табличку с данными необходимыми для конвертации.
    Выход: тип запрашиваемой памяти и её количество или FALSE
 */

 PROC em_begin(epo:PTR TO em_pluginobj)

  RETURN "MEM", (epo.length * число)   -> или RETURN FALSE

 ENDPROC


 /*
   Функция,   которую   EvenMore   вызывает  для  каждого  расширения,  которое
   отозвалось,  что  оно  может сконвертировать предъявленный документ, а она в
   свою очередь вызывает em_parsedata().
 */

 /*
    Вход:  указатель на табличку с данными необходимыми для конвертации.
    Выход: указатель  на  буфер2  содержащий  конвертированный текст и значение
           количества сконвертированных байт.
 */

 PROC em_main(epo:PTR TO em_pluginobj)

 ENDPROC


  -> Функция, зарезервированная для дальнейших версий EvenMore.

 PROC em_end() IS EMPTY


  -> Функция, возвращающая по запросу EvenMore название и версию расширения.

 PROC em_info() IS 'My first plugin 0.0'


  -> Функция, возвращающая идентификатор расширения

 /* 
    На  данный  момент  доступен  только  один  идентификатор "FILE" означающий
    конвертацию  документа  в  обычный  текст.   Возможно в дальнейшем, в новых
    версиях  EvenMore станут, доступны новые возможности и соответственно новые
    идентификаторы для расширений.
 */

 PROC em_pluginid IS "FILE"


  -> Функция, возвращающая название формата файла обрабатываемого расширением.

 PROC em_format IS 'What is shit?! ;)'


  -> Функция, зарезервированная для дальнейших версий EvenMore.

 PROC main() IS EMPTY

 /*
    Функция  появилась, начиная с EvenMore 0.61 и является строго обязательной.
    Служит  для  однозначной  идентификации расширения при его взаимодействии с
    новым  механизмом настроек (prefs) расширений.  Даже если вы не используете
    этот  механизм, вы всё равно должны придумать своему расширению однозначный
    идентификатор.   Если  вы  решили  его  поддержать, обратитесь к исходникам
    расширения GenericPrefs.plugin.
 */

 PROC em_uniqueid() IS 'ewhatitis'

 /* Дальше вы можете писать свои собственные функции и, кстати, вызывать их  из
    обязательных.    Это   путь   к   значительному   расширения   возможностей
    расширений.  
 */


 <HREF "#BEG" alt=" > "> <B>ВЕРНУТЬСЯ В НАЧАЛО</B>


                               .../\  ...^   ...
                                    \/     \/


<#555>

                   <C1>o  СПОСОБЫ ОПРЕДЕЛЕНИЯ ТИПА ДОКУМЕНТА  o</C1>

<C2>    Как  уже  было  сказано выше, существует всего два способа определения типа</C2>
<C2> документа - по его имени (расширению) и по его сигнатуре.</C2>

<C1> Способ первый:</C1>

 PROC em_isdatatype(name)

  DEF fname[256]:STRING
   LowerStr(StrCopy(fname, FilePart(name)))
  IF InStr(fname, '.cpp') > 0
    RETURN TRUE
  ELSE
    RETURN FALSE
  ENDIF
 ENDPROC

<C2>    Этот  способ  менее  предпочтителен,  чем  способ  определения файла по его</C2>
<C2> сигнатуре.   Он подходит для тех типов файлов, которые не имеют никаких жёстко</C2>
<C2> заданных  заголовков,  однозначно  идентифицирующих  их  байтов  и т.д..  Так,</C2>
<C2> например,  не  существует  способа определить, что перед нами именно исходники</C2>
<C2> программы  написанной  на  языке  </C2>C<C2>/</C2>C++<C2>.   Ведь  внутри  файла  с  характерным</C2>
<C2> расширением, на проверку может оказаться всё что угодно.  Поэтому единственным</C2>
<C2> способом определения типа документа является определение его по расширению.</C2>


<C1> Способ второй:</C1>

 PROC em_isdatatype(memadr)

  DEF tstr[10]:STRING
  IF memadr[0] = "@"
   StrCopy(tstr, memadr + 1, 10)
   LowerStr(tstr)
   IF InStr(tstr,'database') = 0 THEN RETURN TRUE
  ENDIF
 ENDPROC

<C2>    Этот  способ  может быть  полезен для определения файлов, про которые точно</C2>
<C2> известно,  что  в  них  по  определённому  смещению  от начала файла находится</C2>
<C2> байт/строка  символов,  которые  однозначно  из идентифицируют.  Например, для</C2>
<C2> архивов  </C2>#?.zip<C2>  это будет строка "</C2>PK<C2>" с нулевым смещением от начала файла.  А</C2>
<C2> для  документации  в  формате  </C2>AmigaGuide<C2>  обязательным считается наличие тега</C2>
 @{database}<C2> в первой строке документа.</C2>

 
<C1> Способ третий:</C1>

<C2>    Я  не буду давать пример, скажу только что этот способ является комбинацией</C2>
<C2> первого  и  второго  способа.   Например,  для  рассмотренного  выше примера с</C2>
<C2> AmigaGuide-документом ничто не мешает программисту, проверить помимо сигнатуры</C2>
<C2> ещё  и  расширение  файла  (</C2>#?.guide<C2>).   Во  всех случаях, когда это возможно,</C2>
<C2> следует  использовать  именно  комбинированный  метод.  Этим вы убережёте своё</C2>
<C2> расширение  от  возможного  зависания  на неверно определённых типах файлов, а</C2>
<C2> пользователя от необходимости изрекать непристойности в ваш адрес.</C2>


<C1> Способ четвёртый:</C1>

<C2>    Под четвёртым способом я понимаю обработку нескольких типов файлов в рамках</C2>
<C2> одного  расширения.   В  этом  случае  вам  потребуется  возвращать  из  вашей</C2>
<C2> процедуры  определённый  ей  тип  файла.   Наиболее удобным видится применение</C2>
<C2> глобальной  переменной  отвечающей  за  тип  файла.  Рассмотрим этот способ на</C2>
<C2> примере   определения  различных  типов  для  файлов  баз  данных  (таблиц)  с</C2>
<C2> расширением </C2>#?.dbf<C2> (для умных - я не рассматриваю индексные файлы).</C2>

 DEF vers = 0                               -> наша глобальная переменная

 PROC em_isdatatype(name, memadr)           -> процедура определения типа файла

  DEF fname[256]:STRING, hbyte:PTR TO CHAR
  LowerStr(StrCopy(fname, FilePart(name)))
  IF InStr(fname, 'dbf') > 0
   hbyte := memadr[0]
   SELECT hbyte
    CASE $3;  vers := 1
    CASE $83; vers := 2
    CASE $8b; vers := 3
    CASE $f5; vers := 4
   ENDSELECT
    RETURN TRUE
   ELSE
    RETURN FALSE
   ENDIF
 ENDPROC


 PROC em_format()             -> процедура автоматически возвращающая тип файла
   SELECT vers
    CASE 1; RETURN 'FoxPro/dBase IV'
    CASE 2; RETURN 'FoxBASE+/dBase III+'
    CASE 3; RETURN 'dBase IV'
    CASE 4; RETURN 'FoxPro'
   ENDSELECT
 ENDPROC

<C2>    Я  думаю уже из одного этого  должно быть понятно, насколько гибок механизм</C2>
<C2> расширений применяемый в программе EvenMore.</C2>


 <HREF "#BEG" alt=" > "> <B>ВЕРНУТЬСЯ В НАЧАЛО</B>


                               .../\  ...^   ...
                                    \/     \/


<#666>

                        <C1>o  ОСНОВНОЙ ЦИКЛ РАСШИРЕНИЯ  o</C1>

<C2>    Как уже упоминалось в главе "Принципы работы расширения", каждое расширение</C2>
<C2> оперирует  двумя  буферами:   источником  (</C2>buffer<C2>),  содержащим  код исходного</C2>
<C2> документа  и  целевым  (</C2>nbuffer<C2>),  содержащим  текст,  полученный в результате</C2>
<C2> работы расширения.  Конвертация одного буфера в другой происходит  в процедуре</C2>
 em_parsedata()<C2>   содержащий   рекурсию,  которую  я  называю  основным  циклом</C2>
<C2> расширения.  При этом исходный документ может быть компрессирован, а  также он</C2>
<C2> как  правило,  в  любом  случае меньше получаемого в целевом буфере текста, за</C2>
<C2> счёт  раздувания  последнего  даже  от небольшого числа ANSI-стилей.  Поэтому,</C2>
<C2> целевой  буфер  назначают,  как  правило,  в  два  раза, а в случае задач типа</C2>
<C2> подсветки исходников, и в три раза больше источника.</C2>

 PROC em_parsedata(epo:PTR TO em_pluginobj) -> указатель на объект epo

  DEF  tempstr[10]:STRING  ->  переменная,  в  которой будет происходить разбор
                               текста

  memadr := epo.buffer   -> получаем указатель на источник (из объекта epo)
  mem2   := epo.nbuffer  -> получаем указатель на целевой буфер
  lenadr := epo.length   -> получаем длину буфера-источника
  count  := 0            -> задаём счётчик для подсчёта конвертированных байтов
  count2 := 0            -> счётчик для указания смещений в целевом буфере

 -> основной цикл, конвертируем пока счётчик не сравняется с длиной источника

   WHILE (count < lenadr)

 -> заносим в строку разбора 10 байт из текущего положения в источнике

    StrCopy(tempstr, memadr+count, 10)

 -> условный разбор строки

    IF InStr(tempstr,'break')=0
     mem2[count2++] := "\e"     -> используя автоинкренемент (приращение)
     mem2[count2++] := "["      -> счётчика смещений, заносим в целевой
     mem2[count2++] := "1"      -> буфер 4 байта ANSI-стиля BOLD
     mem2[count2++] := "m"
     i := 5
      WHILE i                        -> очевидное неудобства любого парсера -
       mem2[count2] := memadr[count] -> недостаточно просто назначать стили,
       INC count; INC count2; DEC i  -> приходится ещё и каждый раз переносить
      ENDWHILE                       -> исходную информацию...
     mem2[count2++] := "\e"
     mem2[count2++] := "["      -> заносим в целевой буфер ещё 4 байта
     mem2[count2++] := "0"      -> ANSI-стиля OFF-CODE (отключаем BOLD)
     mem2[count2++] := "m"
    ELSEIF InStr(tempstr,'catch')=0
     /* код будет идентичен подсветке break */
    ELSEIF InStr(tempstr,'class')=0
     /* и так далее... */
    ENDIF

 -> переносим тот текст, который оставляется As Is - как есть...

    mem2[count2] := memadr[count]
    INC count; INC count2

   ENDWHILE
 ENDPROC

<C2>    Я  думаю,  что  даже самому твердолобому амижнику должно быть  всё понятно.</C2>
<C2> Однако  здесь  возникает  одно  нарекание - применённый  условный разбор строк</C2>
<C2> сложно   назвать   оптимальным,   а  размер  написанного  и  скомпилированного</C2>
<C2> расширения  будет  исчисляться  десятками  килобайт.   Целесообразным  видится</C2>
<C2> вынесение  повторяющихся  участков  кода  в отдельные процедуры, тем более что</C2>
<C2> структура  расширения  это  позволяет  (см.   главу  "Структура  расширения").</C2>
<C2> Оговорюсь  ещё,  что все примеры, приведённые в этой статье намеренно никак не</C2>
<C2> оптимизированы,   чтобы  не  усложнять  изложение  материала.   Вы  же  можете</C2>
<C2> достигнуть в этом направлении весьма неплохих результатов.</C2>

<C2>    Последнее  о  чём  осталось  сказать  - это вызов процедуры </C2>em_parsedata()<C2>,</C2>
<C2> которая  не  является  самостоятельной  и  получает  данные  извне.   Её вызов</C2>
<C2> происходит  из  процедуры  </C2>em_main()<C2>,  которая вызывается EvenMore для каждого</C2>
<C2> подходящего (ключевое слово - подходящего) расширения, вслед за </C2>em_begin()<C2>.</C2>


 /* первая автоматически вызываемая evenmore процедура */

 PROC em_begin(epo:PTR TO em_pluginobj)

 -> вызываем процедуру определения типа файла и передаём ей имя файла
  IF em_isdatatype(epo.filename)

 -> если процедура определения вернула TRUE, то возвращаем запрос куска памяти
 -> в три раза большего, чем исходный документ (длина буфера-источника)

    RETURN "MEM", (epo.length*3)

  ELSE

 -> если процедура определения вернула FALSE, то возвращаем также FALSE, ибо
 -> наше расширение не способно справиться с загруженным документом

    FALSE

  ENDIF
 ENDPROC


 /* вторая автоматически вызываемая evenmore процедура */
 
 PROC em_main(epo:PTR TO em_pluginobj)

  DEF len2

 -> вызываем процедуру разбора данных и получаем на выходе 
 -> действительный размер конвертированного файла

   len2 := em_parsedata(epo)

 -> изменяем поле длины целевого буфера в объекте epo, чтобы evenmore
 -> не выводила данные из неиспользованного куска памяти

   epo.nlength := len2

 ENDPROC 


 <HREF "#BEG" alt=" > "> <B>ВЕРНУТЬСЯ В НАЧАЛО</B>


                               .../\  ...^   ...
                                    \/     \/


<#777>

                      <C1>o  РЕШЕНИЕ РЯДА УСЛОВНЫХ ПРОБЛЕМ  o</C1>

<C2>    В  главе  "Предварительный сбор информации" мы столкнулись с рядом проблем,</C2>
<C2> решение,  которых  было  отложено  "на  потом".  Вообще,  при написании любого</C2>
<C2> расширения  возникают  самые  разнообразные  проблемы,  и  описать  их все  не</C2>
<C2> представляется   возможным.   Поэтому  данная  глава  написана  лишь  с  целью</C2>
<C2> продемонстрировать  характер  возникающих  проблем и подход к их решению.  При</C2>
<C2> этом   я   продолжаю  придерживаться  идеи   некоего  виртуального расширения,</C2>
<C2> подсвечивающего тексты исходных программ на </C2>C<C2>/</C2>C++<C2>.</C2>

<C2>    Сущность  проблемы  в решении задачи одновременного утолщения символа "</C2>*<C2>" и</C2>
<C2> выделения  курсивом  блочных  комментариев "/*  */".  Должно быть понятно, что</C2>
<C2> определение символа "</C2>*<C2>"  должно происходить в расширении уже после определения</C2>
<C2> строк "</C2>/*<C2>"  и  "</C2>*/<C2>", во избежание коллизий.  А вот как быть с такими участками</C2>
<C2> программ на </C2>C<C2>/</C2>C++<C2>:</C2>

 /* 
  *  system include 
  *  for major source
  *  of QuakeIV game
  *  by aGGreSSor^tPA =)
  */ 

 #include <stdio.h> /* Unix forever! */ #include <stdlib.h>

<C2>    Здесь  мы  видим  просто замечательную конструкцию, из которой следует, что</C2>
<C2> если  мы будем просто назначать курсив, встретив в тексте "</C2>/*<C2>" и выключать его</C2>
<C2> встретив "</C2>*/<C2>", то когда мы посреди многострочного комментария встретим "*", то</C2>
<C2> он,  утолстив себя, сделает  выключение  стиля  (</C2>OFF-CODE<C2>).  В результате, все</C2>
<C2> последующие  за  ним  строки останутся без курсива и на "</C2>*/<C2>" мы выключим стили</C2>
<C2> вторично.  Чтобы ликвидировать этот баг, нам придётся переносить (из источника</C2>
<C2> в  целевой  буфер) все данные заключённые между лексемами блочного комментария</C2>
<C2> самостоятельно.   И  учитывать при этом, что в версиях EvenMore до 0.61, конец</C2>
<C2> строки  также  приводит  к  выключению  всех стилей.  Чувствуете, что придётся</C2>
<C2> напрячь извилины?  А теперь, представьте себе что "</C2>*/<C2>" в тексте вообще никогда</C2>
<C2> не  встретиться!   Ну, забыли  его  поставить,  а  вы  его  в  цикле  ищете...</C2>
<C2> Разумеется,  бесконечный цикл = зависание и виновато в этом ваше расширение, а</C2>
<C2> не  этот нехороший EvenMore, который почему-то никак не хочет работать с вашим</C2>
<C2> таким  хорошим расширением.  Виснет он понимаешь, без повода и видимых причин.</C2>
<C2> =)  Хотите еще одну вытекающую отсюда проблему?  Пожалуйста.  Вы ищете в цикле</C2>
<C2> лексему  "</C2>*/<C2>",  а  буфер  уже  кончился...   Лексема  "</C2>/*<C2>" оказалась последней</C2>
<C2> строкой  в  файле  и  после  неё  был  только  один код перевода строки и всё.</C2>
<C2> Одним словом, смотрите сюда:</C2>

 -> задаём счётчик переводов строк
 DEF wrap

 IF InStr(tempstr,'/*')=0

 -> обнуляем счётчик переводов. 
 -> а вы уже приготовили процедуру для включения курсива? =)
   ital(); wrap :=0

    REPEAT

 -> если встретили конец строки,
     IF (memadr[count]) = "\n"

 -> то с новой строкой увеличили счётчик переводов строк
 -> и повторили ansi-стиль курсива с новой строки,
       mem2[count2] := memadr[count]
       INC count; INC count2; INC wrap; ital()

     ELSE

 -> в противном случае просто перенесли один байт.
       mem2[count2] := memadr[count]
       INC count; INC count2

     ENFIF

 -> я не верю, что блочный комментарий бывает больше 24 строк!
        IF (wrap=24) THEN JUMP conti

 -> увы! буфер кончился раньше...
        IF (count>=lenadr) THEN JUMP happy

 -> крутим цикл, пока не найдём лексему "*/".
    UNTIL (memadr[count] = "*") AND (memadr[count+1] = "/")

 reset() -> наконец-то можно выключить стили!

 ELSEIF InStr(tempstr,'*')=0
  bold(); mem2[count2] := memadr[count] -> Здесь должно быть всё понятно...
  INC count; INC count2; reset()
 ENDIF

  -> понятно, что операторы безусловного перехода прокляты всем цивилизованным
  -> миром, но что же делать-то? главное чтобы метка "conti" стояла за нашим с
  -> вами условием. Или применяйте оператор BREAK, как в C/C++.
 conti:

  -> а вот здесь вы уже никак не отвертитесь!
  -> метка "happy" обязана стоять в конце основного цикла...
 happy:


<C2>    Вы кстати, не заметили в этой программе ещё одной проблемы?  Хорошо, раз вы</C2>
<C2> такие   невнимательные,   придётся   рассказать.    В  случае,  когда  блочный</C2>
<C2> комментарий  окажется  таки  растянутым  на  24  строки,  в нашей программе не</C2>
<C2> произойдёт  выключения  стилей  и весь последующий текст (в EvenMore 0.60 - до</C2>
<C2> конца   строки,   а   в  EvenMore  0.61  -  до  конца  текста  или  следующего</C2>
<C2> подсвечиваемого  элемента)  останется  выделяемым курсивом.  Считайте это моей</C2>
<C2> ремаркой  к  вопросу  о  неистребимости  багов  т.к.  я решил оставить вам эту</C2>
<C2> проблему в качестве домашнего задания. =)</C2>

 <HREF "#BEG" alt=" > "> <B>ВЕРНУТЬСЯ В НАЧАЛО</B>


                               .../\  ...^   ...
                                    \/     \/


<#888>

                 <C1>o  ПРОЛЕТАРИИ ВСЕХ СТРАН - ОБЪЕДИНЯЙТЕСЬ!  o</C1>

<C2>    И напоследок я хотел бы рассмотреть один вопрос, который встанет перед вами</C2>
<C2> когда  вы уже напишите своё первое расширение программы EvenMore.  Это вопрос:</C2>
<C2> "А  как  мне  донести  свою  программу  до народа?".  Очень просто. Во первых,</C2>
<C2> релиз  необходимо  выложить  на  </C2>aminet<C2>  (о том, как это сделать - внимательно</C2>
<C2> прочитайте статьи, посвящённые этому вопросу в </C2>PowerAmiga#3<C2> и </C2>PowerAmiga#4<C2>). А</C2>
<C2> во  вторых,  отошлите  своё творение (с аннотацией на английском языке) автору</C2>
<C2> EvenMore - <HREF "#mailto:chris@evenmore.co.uk" alt="Кристиану Перверу">.</C2>

<C2>    Крис  -  обаятельный амижник из Ирландии, 23-х лет от роду.  Он обязательно</C2>
<C2> вам  ответит,  поможет  в  трудных  ситуациях,  выложит  ваше творение на свой</C2>
<C2> официальный  сайт  и  (возможно)  анонсирует его на зарубежных амижных сайтах.</C2>
<C2> Разумеется,  переписка может вестись только на английском языке. Но Крис очень</C2>
<C2> хорошо  относится  к  русским,  и не будет сильно возмущаться по поводу вашего</C2>
<C2> "пигвистического".  Главное, чтобы было понятно, что вы вообще хотели сказать.</C2>

    <HREF "#http://www.evenmore.co.uk" alt="Официальный сайт EvenMore">

 <HREF "#BEG" alt=" > "> <B>ВЕРНУТЬСЯ В НАЧАЛО</B>


<C2><B>                _  _      _  _     _       _  _      _  _  _ _</C2>
<C2>               (-'(_)(/\)(_'( '   (-)(\/)|(_;(-)  ;  (_(_)(_)(_</C2></B>



