
             xxxxxxx                                      xxxxxxx 
             xxx  xxx                                     xxx  xxx
             xxx  xxx                                     xxx  xxx
             xxx  xxx  xxxxxx  xxx xx xxx  xxxxx   xxxxx  xxx  xxx
             xxxxxxxx xxx  xxx xxx xx xxx xxx  xx xxx xxx xxx  xxx
             xxx      xxx  xxx xxx xx xxx xxxxxxx xxx     xxx  xxx
             xxx      xxx  xxx xxx xx xxx xxx     xxx     xxx  xxx
             xxx      xxx  xxx xxx xx xxx xxx  xx xxx     xxx  xxx
             xxx       xxxxxx   xxxxxxxx   xxxxx  xxx     xxxxxxx 


               <C1>o  ВВЕДЕНИЕ В ПРОГРАММИРОВАНИЕ НА ЯЗЫКЕ PowerD  o</C1>


 (ц) Владимир Яворский
 email: jvovka#belnet.ru

<#BEG>

 <HREF "#001" alt=" 1 "> <C2>НЕПРИЯТНОЕ ПРЕДИСЛОВИЕ</C2>
 <HREF "#111" alt=" 2 "> <C2>ИСТОРИЯ ПОЯВЛЕНИЯ</C2>
 <HREF "#222" alt=" 3 "> <C2>ВВОДНАЯ ЧАСТЬ</C2>
 <HREF "#333" alt=" 4 "> <C2>ИНСТАЛЯЦИЯ И ВОЗМОЖНОСТИ</C2>
 <HREF "#444" alt=" 5 "> <C2>ПРОЦЕСС КОМПИЛЯЦИИ</C2>
 <HREF "#555" alt=" 6 "> <C2>АРГУМЕНТЫ КОМПИЛЯТОРА</C2>

<#001>
                         <C1>o  НЕПРИЯТНОЕ ПРЕДИСЛОВИЕ  o</C1>

<I><C2>    Этот  материал  мог  бы  (как  и несколько других) совсем не попасть в этот</C2></I>
<I><C2> номер.   Когда  за большое дело берётся человек привыкший делать всё не просто</C2></I>
<I><C2> спустя  рукава, а остервенело безграмотно и наплевательски, то, честное слово,</C2></I>
<I><C2> лучше  бы  он  не делал этого совсем.  Так, нам в редакцию поступил полный (</C2>!<C2>)</C2></I>
<I><C2> перевод  документации  к </C2> PowerD <C2> выполненный  автором  имя которого вы можете</C2></I>
<I><C2> лицезреть  в  шапке  этой статьи.  Чудовищное количество ошибок, неточностей и</C2></I>
<I><C2> просто   перевранных   мест.    Чего   стоили  хотя  бы  определения  директив</C2></I>
<I><C2> препроцессора:   отныне  мы  обогатились  знанием  о том, что </C2>#ifndef<C2> означает</C2></I>
<I><C2> компиляцию,  если  макрос  определён  (</C2>!<C2>).   Правда  в  оригинале  это звучало</C2></I>
<I><C2> несколько иначе, но оригинал мне не хочется даже приводить.  В конечном итоге,</C2></I>
<I><C2> из  этого материала осталось </C2>5<C2> глав, в которых нет ни буквы авторского текста.</C2></I>
<I><C2> Поймите  меня правильно, я не стал бы паниковать, и разводить истерику - сам я</C2></I>
<I><C2> тоже не безгрешен.  Нам часто поступает близкий к этому по качеству материал и</C2></I>
<I><C2> мы  терпеливо  работаем  с  авторами,  указываем  на  ошибки,  иногда  журим и</C2></I>
<I><C2> результатом  становится  рано  или  поздно  выпускаемый  журнал.   Но когда на</C2></I>
<I><C2> официальный  сайт  </C2>PowerD<C2>  выкладывается  каталог  размером меньше килобайта и</C2></I>
<I><C2> содержащий  </C2>6<C2>  ошибок,  а  также  непонятный  русскому  человеку  перевод, мне</C2></I>
<I><C2> становится  плохо.  Мне не дано понять, что такое "</C2>Отчистка<C2>", я только развожу</C2></I>
<I><C2> руками  и  говорю  "спасибо" от лица всего русскоязычного амижного сообщества.</C2></I>
<I><C2> Ещё  раз  извините  за  неприятное  предисловие,  и  хочется надеяться, что Вы</C2></I>
<I><C2> понимаете его оправданность.</C2></I>

   <I>                                                    / Технический редактор /</I>



<#111>

                      <C1>o  ИСТОРИЯ ПОЯВЛЕНИЯ КОМПИЛЯТОРА  o</C1>

<C2>    Причина  появления  на  свет  компилятора языка PowerD проста - автор писал</C2>
<C2> свои  программы  на </C2> AmigaE<C2>  и  хотел,  чтобы  эти  программы пользовались </C2>FPU
<C2> (мат.сопроцессором),  встроенной поддержки которого как известно в </C2>AmigaE<C2> нет.</C2>
<C2> Для  ликвидации  этого неудобства ему приходилось сначала пользоваться внешней</C2>
<C2> поддержкой <C2> FPU</C2>,  посредством  модуля  написанного  </C2>Michal Bartczak<C2>, а затем и</C2>
<C2> написать  собственный  модуль.   Но  каждый раз, когда требовалось сложить два</C2>
<C2> числа   пользуясь   функциями  модуля,  автора  посещали  грустные  мысли.   В</C2>
<C2> конце-концов   эти   мысли   оформились   в   идею  создать  собственный  язык</C2>
<C2> программирования т.к. параллельно росту опыта программирования на </C2>Amiga<C2>, росла</C2>
<C2> уверенность,  что  компилятор </C2>AmigaE<C2> никогда не будет поддерживать</C2> FPU <C2>и новую</C2>
<C2> линейку процессоров (</C2>PPC<C2>).</C2>

<C2>    Эта история началась в </C2>1998<C2> году, когда автор начал развлекаться с решением</C2>
<C2> уравнений,  изучением  простых  компиляторов  и  т.п..  А в середине </C2>1998<C2> года</C2>
<C2> начался долгий процесс написания первой альфа-версии компилятора языка </C2>PowerD<C2>,</C2>
<C2> работа над которой продолжается и по сей день.</C2>

<C2>    Март</C2> 1999<C2> года принес известие о том, что </C2>Wouter van Oortmerssen <C2>(так зовут</C2>
<C2> автора  компилятора </C2> AmigaE<C2>)  прекращает поддержку своего проекта.  Компилятор</C2>
 AmigaE<C2> был одной из самых ярких возможностей </C2>Amiga<C2>.  СМИ писали даже, что одно</C2>
<C2> его появление, было для платформы таким же событием, как чипсет </C2>AGA<C2> (сделавшей</C2>
<C2> её  популярной),  </C2>RISC<C2>-процессору</C2> Copper <C2>(заставивший мир по-другому взглянуть</C2>
<C2> на   игры   и   операционную   систему)  и  интерфейс </C2> MUI<C2>  (первый  полностью</C2>
<C2> объектно-ориентированный интерфейс).</C2>

    E<C2>  -  язык  процедурного  программирования,  но  он  вобрал  в  себя многие</C2>
<C2> возможности  объектно-ориентированного, параллельного и даже функционального и</C2>
<C2> логического  схем  программирования.   Он сравним с такими языками как </C2>С<C2>, </C2>C++<C2>,</C2>
 Ada<C2>,</C2>   Pascal<C2>,</C2>   Lisp<C2>,</C2>   Miranda<C2>,</C2>  Prolog<C2>  и </C2> Haskel<C2>.   И  несмотря  на  столь</C2>
<C2> разнообразные  возможности,  </C2>E<C2>  обладает  к  тому  же,  одним из самых быстрых</C2>
<C2> компиляторов на всей платформе </C2>Amiga<C2> (</C2>AmigaE<C2>).</C2>

<C2>    Однако  компилятор  </C2>AmigaE<C2> не был лишен и известных недостатков. К счастью,</C2>
<C2> большинство из них удалось исправить польскому программисту </C2>Tomasz Wiszkowski<C2>.</C2>
<C2> В  </C2>2000 <C2> году  для скачивания из архивов </C2>aminet<C2> стал доступен новый компилятор</C2>
 CreativE   2.12<C2>,   решающий  множество  проблем  связанных  с  статистическими</C2>
<C2> списками,  операторами,  а  также во многом приближенный к синтаксису языка </C2>C<C2>.</C2>
<C2> Однако, этот проект (увы!) канул в лету.  И долгое время казалось, что попытки</C2>
<C2> пролезть вперёд "Батяни СИ" можно оставить, но...</C2>

<C2>    ...в  далёком  </C2>1993<C2> году, скромный чешский паренёк </C2>Martin Kuchinka<C2> приобрёл</C2>
<C2> свою первую </C2>Amiga A1200<C2>.  В мечтах о собственных программах </C2>3D<C2>-рейтрейсинга он</C2>
<C2> прошёл  путь  от </C2>AMOS<C2> до</C2> C<C2>, не миновав по пути </C2>68k Assembler <C2>и</C2> Pascal<C2>.  В </C2>1995
<C2> году  в  его  руки попал комилятор </C2>AmigaE<C2>.  Когда же наступил </C2>1996<C2> год, он уже</C2>
<C2> стал зарегестрированным пользователям этого компилятора, полностью погружённым</C2>
<C2> в  написание  собственного </C2>3D<C2>-рейтрейсера.  Мечты начинали сбываться!  Однако,</C2>
<C2> после   покупки  акселлератора </C2> Blizzard  1230/50<C2>  с  предустановленными  </C2>16Mb
 Fast<C2>-памяти  и  </C2>FPU<C2>,  выяснилось,  что  </C2>AmigaE<C2>  всё-таки  не  самый подходящий</C2>
<C2> инструмент для вычислений с плавующей точкой.  Закончив свой проект (частью на</C2>
 C<C2>, частью на </C2>AmigaE<C2>) </C2>Martin<C2> решил, что "пришло время создать язык, который был</C2>
<C2> бы "одинаково хорош для всего"...</C2>

<C2>    Таким  образом,  к  ноябрю </C2>2002<C2> года амижное сообщество смогло порадоваться</C2>
<C2> появлению  нового  компилятора  мощнейшего языка программирования - </C2>PowerD<C2> (на</C2>
<C2> момент написания статьи доступна версия </C2>0.20a6<C2>)</C2>

<#222>
                              <C1>o  ВВОДНАЯ ЧАСТЬ  o</C1>


<C2>    PowerD  имеет  синтаксис  во  многом сходный с принятым в AmigaE, однако он</C2>
<C2> может считаться вполне самостоятельным языком.  Посмотрим, как будет выглядеть</C2>
<C2> ставшее классическим ругательство, на языке PowerD:</C2>


<C2> // простейший пример.</C2>

 OPT DOSONLY  <C2>// открывается только dos.library.</C2>

 PROC main()
 PrintF('Fucking World!\n')
 ENDPROC


<C2>    А так будет выглядеть эта же программа транслированная при помощи PowerD на</C2>
<C2> язык ассемблера:</C2>

        machine mc68020
        fpu     1

        xdef    _main
 _main
        movem.l d2/a6,-(a7)
        lea     str0,a0
        move.l  a0,d1
        moveq   #0,d2
        movea.l _DOSBase,a6
        jsr     (-954,a6)
 mainend
        xdef    mainend
        moveq   #0,d0
 mainfinish
        movem.l (a7)+,d2/a6
        rts

        section ".tocd",data
        xref    _exception
        xref    _exceptioninfo
        xref    _stdrast
        xref    _DOSBase
        xref    _ExecBase
 str0	dc.b    "Fucking World!",10
        dc.b    0

<C2>    После  компиляции  транслированной  программы  ассемблером  PhxAss,  размер</C2>
<C2> исполняемого  файла  будет  составлять  всего  176  байт (против 16-ти и более</C2>
<C2> килобайт обычных для компиляторов C, и тем более C++)</C2>

<C2>    Вряд ли Вы сможете получить столь малый исполняемый файл настолько просто и</C2>
<C2> эффективно где бы то ни было еще...</C2>

<#333>
                  <C1>o  ИНСТАЛЯЦИЯ И ВОЗМОЖНОСТИ КОМПИЛЯТОРА  o</C1>

<C2>    Для  того,  чтобы писать вот такие вот красивые программы (Fucking World!),</C2>
<C2> Вам  потребуется  пакет  PowerD.  Он свободно распространяется  и  доступен на</C2>
<C2> aminet (dev/e/powerd.lha). Этот архив занимает приблизительно 900Кб.</C2>

<C2>    Скачав   архив,   распакуйте   его   в   какую-либо  директорию  (например:</C2>
<C2> "Work:PowerD") и добавьте в Ваш User-Startup следующий текст:</C2>


 Assign D:        <имя выбранной директории>
 Assign DModules: D:modules
 Path D:          D:bin ADD


<C2>    Требования к компьютеру предъявляются самые скромные:</C2>

 1. Любая Amiga или совместимый с ней компьютер;
 2. Хотя-бы AmigaOS 3.0 (V39+);
 3. жёсткий диск, дискеты просто вышли сегодня из моды;
 4. 2 Мб свободной памяти (иногда могут понадобиться все 4 Мб);
 5. Ассемблер PhxAss (автор Frank Wille);
 6. Линковщик PhxLnk (автор Frank Wille);

<C2>    Однако, рекомендуется:</C2>

 1. Как можно больше свободно памяти (16-32 Мб хватит на всё);
 2. Как можно более быстрый CPU (приемлимая работа начинается с 030/50 МГц);
 3. Математический сопроцессор (в простонародье именуемый FPU).


<C2> Имеются и известные ограничения:</C2>

<C2> Относящиеся к железу:</C2>

    Число  возвращаемых  функцией  значений  ограничено числом регистров данных
 используемого  процессора  (для  68k - это 8 и ещё 8, если имеется FPU), а для
 PowerPC это 25 из процессорных + 32 принадлежащих FPU).

<C2> Заложенные в компиляторе (читать, как: "исправляемые в процессе развития"):</C2>

    Любой  объект может включать не больее 32-х определений, длина любого имени
 (например,  метки,  имени  функции  и  т.п.)  должна  быть меньше 64 символов,
 максимальная  длина  одной  строки  программного кода не должна превышать 1024
 символов,  недопустимы макросы размером более 16Кб, а максимальная вложенность
 макро-определений - до 8 уровней.


<C2>    Приоритеты PowerD по сравнению с компиляторами C и C++:</C2>

 1.  Функции могут возвращать больше значений;
 2.  Списки  могут  быть  определены и использованы где угодно,
     а не только в области определения;
 3.  Легко читаемый, интуитивно-понятный синтаксис;
 4.  Используются бинарные модули;
 5.  Компиляция происходит на порядки быстрее;
 6.  Компилятор расходует гораздо меньше памяти.

<C2>    Приоритеты PowerD по сравнению с компиляторами E:</C2>

 1.  Функции могут возвращать больше значений;
 2.  Понимаются C-подобные выражения (например: >>, <<, >|, <| и т.п.);
 4.  Более осмысленная математика (например, в PowerD: 1+2*3=7, тогда, как в
     AmigaE: 1+2*3=9);
 5.  Возможность изменения приоритета операций;
 6.  Имена могут содержать буквы обоих регистров;
 7.  Для ООП вам не надо использовать self.#?, можно лишь #?
 8.  Полиморфизм языка, стал действительно похож на полиморфизм;
 9.  Доступно больше типов данных (FLOAT, DOUBLE, BOOL и т.д.);
 10. Компиляция использующая FPU;
 11. Компиляция объектных файлов;
 12. Автоматическая генерация внешних модулей;
 13. Подключение функций библиотек;
 14. Перичисляемые списки (например, OpenWindowTags/OpenWindowTagList);
 15. IFN, WHILEN, и т.д. для реверсивного сравнения 
     (IF a<>10 тоже, что IFN a=10);
 16. Константы и переменные могут быть объявлены где угодно;


<C2>    Недостатки PowerD по сравнению с компиляторами C и C++:</C2>

 1.  Недоразвитость возможностей ООП.

<C2>    Недостатки PowerD по сравнению с E:</C2>

 1. Компиляция происходит всё-таки медленнее.


<#444>

                           <C1>o  ПРОЦЕСС КОМПИЛЯЦИИ  o</C1>

<C2>    Итак,  Вы  скачали  или другим образом получили дистрибутив PowerD.  Удачно</C2>
<C2> (по  Вашему  мнению)  инсталировав  его,  первое  что  имеет  смысл  сделать -</C2>
<C2> проверить  компилируются ли входящие в дистрибутив исходники примеров, и, если</C2>
<C2> нет,  попытаться  локализовать  и  исправить ошибки инсталяции, версий и т.п..</C2>
<C2> Для компиляции (например) программы "fuckingworld.d", наберите в CLI:</C2>

    1.> dc D:examples/fuckingworld.d

<C2>    Компилятор начнёт свою работу, и, возможно собъётся где-то по пути. Логично</C2>
<C2> рассмотреть  все  этапы  компиляции,  чтобы  Вы  смогли локализовать возникшую</C2>
<C2> проблему:</C2>


 PowerD v0.1: PreProcessing(100)...
<C2>    На   этом   этапе   интерпретируются  макросы,  начиная  с  первых  уровней</C2>
<C2> вложенности и далее.</C2>
	
 PowerD v0.1: Reading(100)...
<C2>    Чтение  и  конвертация  источника данных в ассемблер согласно установленным</C2>
<C2> правилами (опции, препроцессор и т.д.).</C2>
	
 PowerD v0.1: Reading(100) in intuition/intuition...
<C2>    Подключение функций из модулей которые были объявлены в программе.</C2>

 PowerD v0.1: Working...
<C2>    Генерация списка объектов и перекрёстных ссылок.</C2>
 
 PowerD v0.1: Writing(12%)...
<C2>    Оптимизация и сохранение программы конвертированной в мнемоники ассемблера.</C2>
 
 PowerD v0.1: Cleaning...
<C2>    Освобождение памяти.</C2>

 PowerD v0.1: Compiling...
<C2>    Передача конвертированной программы ассемблеру PhxAss.</C2>
 
 PowerD v0.1: Linking...
<C2>    Связывание заголовка, объектов и библиотек линковщиком PhxLnk.</C2>
 
 PowerD v0.1: Done.
<C2>    Если все этапы компиляции прошли успешно.</C2>

 PowerD v0.1: Not Done.
<C2>    Если на каком-то (любом) этапе возникла ошибка.</C2>


<C2>    Чаще  всего  ошибки  возникают  вследствии  неверной  инсталяции (или вовсе</C2>
<C2> отсутствия)   ассемблера  PhxAss  и/или  линковщика  PhxLink.   Потом,  пальму</C2>
<C2> первенства  держат  ошибки  согласования версий (автор компилятора не очень-то</C2>
<C2> внимательно  относится  к  этому  вопросу,  а  это  в  свою  очередь порождает</C2>
<C2> частичную несовместимость исходных текстов программ.  Например, как в случае с</C2>
<C2> примерами  для  Reacion).   Ну,  и  наконец, ошибки самого PowerD (куда же без</C2>
<C2> них?).</C2>

<#555>

                          <C1>o  АРГУМЕНТЫ КОМПИЛЯТОРА  o</C1>

<C2>    Компилятор  PowerD представлен файлом "dc", который расположен в директории</C2>
<C2> "bin" дистрибутива.    Часто  для  компиляции программы  не требуется  вводить</C2>
<C2> никаих  аргументов,  но по мере роста Вашего опыта, вы начнёте использовать их</C2>
<C2> всё чаще, и чаще. Здесь приведены только наиболее важные аргументы:</C2>


 SOURCE/A (по умолчанию: генерация сообщения об ошибке)
<C2>   Указывает на исходник программы написанной на языке PowerD.</C2>

 DEST (по умолчанию: <имя файла>, где имя файла вводится без расширения)
<C2>   Указывает на создаваемый исполняемый файл.</C2>

 TO=TOOBJECT/K (по умолчанию: <имя файла>.o, имя файла вводится без расширения)
<C2>   Указывает на создаваемый объектный файл. Соответствует опции OBJECT.</C2>

 GM=GENMODULE/S (по умолчанию: отключен)
<C2>   Указывает,  что  создаваемый  исполняемый  файл является внешним модулем (по</C2>
<C2>   сути,  равнозначно  обыкновенной  библиотеке).  Может оказаться полезным для</C2>
<C2>   разделения функций, переменных и объектов модуля между несколькими программи</C2>
<C2>   (проект).   Расширение  создаваемого  модуля  -  ".m", что ведёт к известной</C2>
<C2>   путанице  с  исходными  текстами  модулей  на  E, имеющими то же расширение.</C2>
<C2>   Начиная с версии PowerD 0.18 появилась возможность создавать ASCII-модули.</C2>

 CO=CHECKONLY/S (по умолчанию: создание исполняемого файла)
<C2>   Блокирует создание объектных файлов.  Может оказаться полезным для ускорения</C2>
<C2>   компиляции в целях проверки синтаксиса.</C2>

 NS=NOSOURCE/S (по умолчанию: показывает источник ошибки)
<C2>   Если присутствует этот аргумент и в процессе компиляции возникает ошибка, то</C2>
<C2>   будет  отображён  только  номер  строки (текст программы вызвавший ошибку не</C2>
<C2>   отображается).</C2>

 AI=ASMINFO/S (по умолчанию: не включён)
<C2>   Принуждает  компилятор  генерировать комментарии при трансляции программы на</C2>
<C2>   язык ассемблера, в целях повышения её читабельности (специальная функция для</C2>
<C2>   кодеров).</C2>

 DS=DEBUGSYM/S (по умолчанию: не включён)
<C2>   Принуждает  компилятор  генерировать  символьные  файлы, которые затем можно</C2>
<C2>   использовать  в  отладке программы.  Это единственный способ воспользоваться</C2>
<C2>   отладчиками сторонних авторов, такими как MonAm, или Barfly.</C2>

 NU=NOUNUSED/S (по умолчанию: не включён)
<C2>   Блокирует  генерацию  предупреждений  о  неиспользованных, но  объявленных в</C2>
<C2>   программе функциях и/или переменных.</C2>

 I=INFO/S (по умолчанию: не включён)
<C2>   Принуждает   компилятор   выводить   информацию  о  времени  затраченном  на</C2>
<C2>   компиляцию и использованных ресурсах после завершения этого процесса.</C2>


 CPU=MACHINE/N  (по  умолчанию: 68020+881)
<C2>   Соответствует опции CPU.  Обратите внимание на то, что процессоры до MC68020</C2>
<C2>   компилятором не поддерживаются. MC68020 - это необходимый минимум.</C2>

 NOFPU/S (по умолчанию: 68881 fpu)
<C2>   Соответствует опции NOFPU.  Принуждает компилятор не использовать  поддержку</C2>
<C2>   FPU.  Может оказаться полезным, если такого устройства у Вас нет (очень даже</C2>
<C2>   может быть, в условиях амижной действительности).</C2>

 O=OPTIMIZE/N (по умолчанию: 0)
<C2>   Соответствует опции OPTIMIZE. Числовой критерий оптимизации, тот же самый.</C2>

 NOEXE/S (по умолчанию: создание исполняемого файла)
<C2>   Соответствует опции NOEXE. Блокирует создание оптимизационного файла.</C2>

 DF=DELFILES/S (по умолчанию: не включён)
<C2>   Принуждает  удалять  генерируемый  в процессе компиляции, промежуточный файл</C2>
<C2>   программы на языке ассемблер (с расширением ".ass").</C2>



<B><C1>                _  _      _  _     _       _  _      _  _  _  _</C1></B>
<B><C1>               (-'(_)(/\)(_'( '   (-)(\/)|(_;(-)  ;  (_(_)(_)'/)</C1></B>




