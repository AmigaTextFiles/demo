<#BEG>

                          <C2>xx   xxx</C2>  <C1>-)-)-)-)-)-)-)-)</C1>
                          <C2>XX  XXX</C2>  <C1>-)-)-)-)-)-)-)-)</C1>
                          <C2>XX XXX</C2>                     
                          <C2>YYYYY</C2>  Y  YYY YY YY  YYYY  
                          <C2>YYYY</C2>     YYY  YY YY YY     
                          <C2>YY!</C2>  YY! Y!   YY YY  YYY   
                          <C2>!;</C2>   !!  !;   !! !;    !;  
                          <C2>;</C2>   !!!! ;;    ;;;  ;;;;   


                     <C1>. . .  ВИРУСОЛОГИЯ НА AMIGA  . . .</C1>


 (<C2>ц</C2>) <C2>Егор Егоров</C2> aka <C2>MadCr</C2>
 <C2>email:</C2> <HREF "#mailto:madrats@mail.ru" alt="madrats@mail.ru">



 [<HREF "#001" alt=" 1 ">] <C2>ОТ АВТОРА</C2>
 [<HREF "#002" alt=" 2 ">] <C2>СТРУКТУРА ИСПОЛНЯЕМЫХ ФАЙЛОВ</C2>
 [<HREF "#003" alt=" 3 ">] <C2>ЗАГРУЗКА ИСПОЛНЯЕМЫХ ФАЙЛОВ</C2>
 [<HREF "#004" alt=" 4 ">] <C2>ИНФИЦИРОВАНИЕ ИСПОЛНЯЕМЫХ ФАЙЛОВ</C2>
 [<HREF "#005" alt=" 5 ">] <C2>КАК ОСТАТЬСЯ РЕЗИДЕНТОМ?</C2>


                                                    
<#001>

<I><C2>    Сразу   хочу   предупредить:    данная  статья  была  написана  в  качестве</C2></I>
<I><C2> образовательного   материала   и   исключительно   ради  удовлетворения  моего</C2></I>
<I><C2> любопытства.   Не  следует  воспринимать  её  как  попытку  подтолкнуть  Вас к</C2></I>
<I><C2> написанию  вирусов,  и  тем более не хотелось бы, чтобы Вы сочли этот материал</C2></I>
<I><C2> чем-то экстраординарным и новым.</C2></I>

<I><C2>    В этой статье (если у читателей возникнет интерес, то, возможно, появится и</C2></I>
<I><C2> продолжение),  я  постарался передать Вам минимум знаний в области вирусологии</C2></I>
<I><C2> на  Амиге.   Я  надеюсь,  что выбранный предмет беседы окажется интересным для</C2></I>
<I><C2> начинающих программистов и не вызовет негативных реакций.</C2></I>

<I>                                                                  / ОТ АВТОРА /</I>


 <HREF "#BEG" alt=" > "> <B>ВЕРНУТЬСЯ В НАЧАЛО</B>

<C1>                 _,,             _,,             _,,         </C1>
<C1>                 "-.\=           "-.\=           "-.\=       </C1>
<C1>                   \\=   _.~       \\=   _.~       \\=   _.~</C1>
<C1>                  _|/||||)_       _|/||||)_       _|/||||)_ </C1>
<C1>                  \        \      \        \      \        \</C1>


<#002>
                      <C1>o  СТРУКТУРА ИСПОЛНЯЕМЫХ ФАЙЛОВ  o</C1>


<C2>    Для  начала  рассмотрим структуру стандартных исполняемых файлов в </C2><C1>AmigaOS</C1><C2>.</C2>
<C2> В  связи  с тем, что библиотека </C2>dos.library<C2> была написана авторами в некоторой</C2>
<C2> спешке  (причем  на  языке  </C2>BCPL<C2>) возникает ряд нюансов.  Например, все данные</C2>
<C2> должны быть выровнены по </C2>32<C2>-х битному значению.  Поэтому не удивительно, что в</C2>
<C2> исполняемом файле все поля окажутся также </C2>32<C2>-х битными. </C2>

<C2>    Исполняемый файл можно логически разделить на 3 части:</C2>

       1<C2>. Заголовок (</C2>header<C2>).</C2>
       2<C2>. Таблица резервирования памяти (</C2>memalloc table<C2>).</C2>
       3<C2>. Секции (</C2>hunks<C2>).</C2>

<C2>                                        Рассмотрим каждую часть более подробно.</C2>




    Заголовок (header) - занимает 20 байт


 1 поле: <C2>тип секции (</C2>hunk_header<C2>).  Например, <C2>$000003f3</C2>.  Здесь  и  далее, поле</C2>
         <C2>(</C2>field<C2>) принимается равным </C2>4<C2>-м байтам.</C2>

 2 поле: <C2>длина имени резидентной/разделяемой библиотеки.  Это  поле  необходимо</C2>
         <C2>заполнять  только  при  создании  разделяемых  (</C2>shared<C2>)  файлов.   Для</C2>
         <C2>обычного исполняемого файла его значение будет:</C2> $00000000<C2>.</C2>

 3 поле: <C2>количество секций  в  файле (включая резидентные библиотеки).  Секции,</C2>
         <C2>как известно, типизированы.  Из опыта использования пакета Devpac, Вам</C2>
         <C2>уже должны быть известны такие типы секций как: </C2>code<C2>, </C2>data<C2> и </C2>bss<C2>.</C2>

 4 поле: <C2>Номер первой секции  (отсчет ведётся с нуля, соответственно для первой</C2>
         <C2>это будет значение</C2> $00000000<C2>)</C2>

 5 поле: <C2>Номер последней секции  (отсчет ведётся с нуля, поэтому значение будет</C2>
         <C2>равно числу имеющихся в файле секций минус единица.</C2>


    Таблица резервирования памяти (memalloc)


<C2> Эта  таблица  имеет  столько же полей, сколько имеется секций в файле.  Каждое</C2>
<C2> поле таблицы  содержит значение, указывающее на объём памяти резервируемый для</C2>
<C2> соответствующей  ей секции.  Здесь имеется одна тонкость, связанная с тем, что</C2>
<C2> объём   резервируемой  памяти  задаётся  не  в  байтах,  а  в  длинных  словах</C2>
<C2> (</C2>longword<C2>).</C2>


    Секции (hunks)
 

<C2> Размер  секции  зависит  от  её  типа.   Секции  всегда  имеют поле  заголовка</C2>
<C2> (</C2>hunk_code<C2>).    Содержание   секции   после   заголовка  может  различаться  в</C2>
<C2> зависимости  от  её  типа.   Для секций содержащих код (тип "</C2>code<C2>") или данные</C2>
<C2> (тип "</C2>data<C2>") сразу за заголовком следуют:</C2>

    1. <C2>поле, содержащее длину секции (задаётся в </C2>longwords<C2>).</C2>
    2. <C2>данные.</C2>
    3. <C2>секции релоцирования и/или символов.</C2>
    4. <C2>поле, содержащее признак конца секции (</C2>hunk_end<C2>) -</C2> $000003f2
 


<C2>    Рассмотрим первую секцию, следующую за таблицей резервирования памяти. Если</C2>
<C2> она  имеет  тип  "</C2>code<C2>",  то ему соответствует значение </C2>$000003e9<C2> в заголовке.</C2>
<C2> Далее   мы   увидим   её  длину,  данные  (непосредственно  сам  код),  секции</C2>
<C2> релоцирования   (иначе,   </C2>reloc<C2>)   и/или   символов  (иначе,  </C2>symbol<C2>  -  могут</C2>
<C2> отсутствовать)  и  код  </C2>$000003f2<C2>  обозначающий,  что  рассматриваемая  секция</C2>
<C2> кончилась.   Рассмотрим  "загадочные"  вложенные секции.  Секция релоцирования</C2>
<C2> служит  для  описания  ссылок  внутри  секции,  а  также  из  секции в секцию.</C2>
<C2> Например,  исполняемый  файл будет содержать секцию </C2>reloc<C2> уже после компиляции</C2>
<C2> следующего кода:</C2>


 start:
        jmp start
 end
 

<C2>    Должно быть понятно, что секция </C2>reloc<C2> не может существовать "сама по себе".</C2>
<C2> Она  обязательно  является  вложенной  в  секцию,  либо типа "</C2>code<C2>", либо типа</C2>
<C2> "</C2>data<C2>".   Всего  существует  3  разновидности секции </C2>reloc<C2> (</C2>reloc32<C2>, </C2>reloc16<C2> и</C2>
 reloc8<C2>),  но по объективным причинам, мы рассмотрим только </C2>reloc32<C2>.  Структура</C2>
<C2> секции </C2>reloc32<C2> будет следующей:</C2>

 1 поле: hunk_reloc32 <C2>(</C2>$000003ec<C2>).</C2>
 2 поле:<C2> число ссылок.</C2>
 3 поле: <C2>порядковый номер секции, на которую происходит ссылка.</C2>

<C2>    Следом,  в  зависимости  от  количества  ссылок, будут расположены поля (по</C2>
<C2> одному  на  каждую  существующую  ссылку),  в  которых указываются смещения от</C2>
<C2> начала кода.  Указателем того, что секция </C2>reloc<C2> закончилась, является значение</C2>
 $00000000<C2>.</C2>

<C2>    Для  более полного понимания, посмотрим, какой исполняемый файл сгенерирует</C2>
<C2> ассемблер </C2>GenAm<C2> из пакета </C2>Devpac<C2>, на классическом примере "</C2>hello world<C2>":</C2>

 start:	

        move.l   #dosl,a1             <C2>; указатель на имя открываемой библиотеки</C2>
        move.l   4,a6                 <C2>; указатель на exec.library (execbase)</C2>
        jsr      -$228(a6)            <C2>; открываем библиотеку dos.library</C2>
        move.l   d0,a6                <C2>; получаем указатель на библиотеку (в d0)</C2>

        jsr      -$3c(a6)             <C2>; получаем указатель на stdout (в d0)</C2>
                                      <C2>  (вызов функции из dos.library)</C2>

        move     d0,d1                <C2>; в d1 - полученный указатель на stdout</C2>
        move.l   #text,d2             <C2>; в d2 - указатель на печатаемый текст</C2>
        moveq    #13,d3               <C2>; в d3 - число символов в тексте</C2>
        jsr      -$30(a6)             <C2>; печатаем текст через stdout</C2>
                                      <C2>  (вызов функции из dos.library)</C2>

        eor      d0,d0                <C2>; "вспоминаем" указатель на dos.library</C2>
        move     d0,a1                <C2>; в a1 указатель на dos.library</C2>
        move.l   4,a6                 <C2>; указатель на exec.library (exec base)</C2>
        jsr      -$19e(a6)            <C2>; закрываем библиотеку dos.library</C2>

        rts                           <C2>; возвращаемся в систему</C2>

 dosl:  dc.b     "dos.library",0
 text:  dc.b     "Hello World!",$a
 end


<C2>    Ассемблируем написанную программу:</C2>

<B> Amiga Shell:> genam hello_world.s</B>
               ... bla bla bla ...


<C2>    Исполняем получившийся файл:</C2>

<B> Amiga Shell:> hello_world</B>
 Hello World!


<C2>    Смотрим, сколько он занимает:</C2>

<B> Amiga Shell:> list nodates nohead hello_world</B>
 hello_world             136  ----rwed



<C2>    Итак, у нас получился исполняемый файл "</C2>hello_world<C2>" размером </C2>136<C2> байт.</C2>
<C2> Из них:</C2>

  20 <C2>байт</C2>  - <C2>заголовок (</C2>header<C2>)</C2>
   4 <C2>байта</C2> - <C2>таблица (</C2>memaloc table<C2>)</C2>
 112 <C2>байт</C2>  - <C2>секция типа "</C2>code<C2>":</C2>

             4 <C2>байта</C2> - <C2>заголовок секции</C2>
	     4 <C2>байта</C2> - <C2>длина секционных данных</C2>
            76 <C2>байта</C2> - <C2>непосредственно код (в него и данные всунули)</C2>
	    24 <C2>байт</C2>  - <C2>вложенная секция типа "</C2>reloc32<C2>" (</C2>reloc32_hunk<C2>)</C2>
	     4 <C2>байт</C2>  - <C2>признак конца секции (</C2>end_hunk<C2>)</C2>


<C2>    Кстати,  отсюда  видно,  что </C2>GenAm<C2> не генерирует вообще, чего бы то ни было</C2>
<C2> лишнего.   И  это  говорит  только  в  его пользу.  Соответственно и уменьшить</C2>
<C2> исполняемый  файл  путем  отрезания каких-либо не нужных секций нам не удастся</C2>
<C2> (не в пример формату исполняемых файлов </C2>elf<C2>, где "воды" более чем достаточно).</C2>

<C2>    Секция  типа  "</C2>data<C2>"  (которую  по  хорошему  мы  должны были бы определить</C2>
<C2> отдельно),  имеет  точно  такую  же  структуру,  что и секция типа "</C2>code<C2>".  За</C2>
<C2> исключением названия самой секции (</C2>$00003ea<C2> в нашем случае).</C2>

<C2>    Конечно,  существует  множество секций и других типов (</C2>например<C2>,</C2> bss<C2>,</C2> name<C2>,</C2>
 debug <C2> и  др.),  но  пока они нам пока не понадобятся и рассматривать их мы не</C2>
<C2> будем.</C2>


 <HREF "#BEG" alt=" > "> <B>ВЕРНУТЬСЯ В НАЧАЛО</B>

<C1>                 _,,             _,,             _,,         </C1>
<C1>                 "-.\=           "-.\=           "-.\=       </C1>
<C1>                   \\=   _.~       \\=   _.~       \\=   _.~</C1>
<C1>                  _|/||||)_       _|/||||)_       _|/||||)_ </C1>
<C1>                  \        \      \        \      \        \</C1>



<#003>
                       <C1>o  ЗАГРУЗКА ИСПОЛНЯЕМЫХ ФАЙЛОВ  o</C1>


<C2>    Загружаемый  файл  сначала проходит проверку загрузчиком и в зависимости от</C2>
<C2> результата  проверки  исполняется  как  файл одного  из  поддерживаемых типов.  </C2>
<C2> В</C2> 68k<C1> AmigaOS</C1><C2> поддерживаются два типа исполняемых файлов:</C2>


 1<C2>. обычные исполняемые (рассмотрены выше), с необязательным расширением</C2> exe<C2>.</C2>

 2<C2>. резиденты (</C2>residents<C2>):</C2>

              #?.library  - <C2>библиотеки;</C2>
              #?.device   - <C2>устройства;</C2>
              #?.datatype - <C2>типы данных;</C2>
              #?.resource - <C2>ресурсы;</C2>

                 <C2>и т.д.</C2>

<C2>    Для  верного  определения  типа  исполняемого файла, проверка происходит по</C2>
<C2> множеству критериев: производиться сверка с таблицей возможных секций (</C2>hunks<C2>),</C2>
<C2> проверка на наличие полей специфичных для найденных секций и многое другое.</C2>

<C2>    Фрагментированная  загрузка  файла  в  память  (вспоминаем, что речь идёт о</C2>
 dos.library<C2>)  производится  вызовом  функции </C2> LoadSeg()<C2> или </C2>InternalLoadSeg()<C2>.</C2>
<C2> Первый  вариант  особенно  прост:   аргумент  у  функции  только  один  -  имя</C2>
<C2> загружаемого  файла.   Функция  после  вызова  возвращает  указатель на список</C2>
<C2> сегментов  (по  одному  сегменту  на  каждую секцию).  Структура сегментов для</C2>
<C2> обычных исполняемых файлов выглядит так:</C2>

   -4 - <C2>длина сегмента + </C2>8<C2> (в байтах)</C2>
    0 - <C2>указатель на адрес следующего сегмента в списке (</C2>0<C2> для последнего)</C2>
    4 - <C2>точка входа в данные. </C2>

<C2>    Если  же  загружаемый  файл  является  резидентным,  то структура сегментов</C2>
<C2> заметно  усложняется.   Она  состоит  уже  из  двух  описателей:  </C2> matchword<C2> и</C2>
 matchtag <C2>и занимает </C2>26<C2> байт:</C2>


 struct Resident 

 {

<C1> -- первая структура (matchword, занимает 2 байта):</C1>

 MatchWord -<C2> Содержит специальный ОП-код.</C2>
            <C2> Например, для "</C2>illegal<C2>" значение будет </C2>$4afc<C2>.</C2>

<C1> -- вторая структура (matchtag, занимает 24 байта):</C1>

 4 <C2>байта</C2> MatchTag  - <C2>адрес на matchtag данные (т.е. на следующую ниже запись)</C2>

   4 <C2>байта</C2> EndSkip   - <C2>где продолжать поиск</C2>
   1 <C2>байт </C2> Flags     - <C2>флаги</C2> 1<<7
   1 <C2>байт </C2> Version   - <C2>номер версии резидента</C2>
   1 <C2>байт </C2> Type      - <C2>тип резидента (</C2>library<C2>,</C2> device<C2>,</C2> datatype<C2>, и т.д.)</C2>
   1 <C2>байт </C2> Priority  - <C2>приоритет инициализации</C2>
   4 <C2>байта</C2> Name      - <C2>указатель на имя модуля</C2>
   4 <C2>байта</C2> IdString  - <C2>указатель на идентификационную строку</C2>
   4 <C2>байта</C2> Init      - <C2>указатель на структуру автоинициализации или</C2>
                       <C2>процедуру, выполняющую инициализацию резидента</C2>

 };


 <HREF "#BEG" alt=" > "> <B>ВЕРНУТЬСЯ В НАЧАЛО</B>

<C1>                 _,,             _,,             _,,         </C1>
<C1>                 "-.\=           "-.\=           "-.\=       </C1>
<C1>                   \\=   _.~       \\=   _.~       \\=   _.~</C1>
<C1>                  _|/||||)_       _|/||||)_       _|/||||)_ </C1>
<C1>                  \        \      \        \      \        \</C1>


<#004>
                             <C1>o  ИНФИЦИРОВАНИЕ  o</C1>


<C2>    Итак,  мы  кратко,  но  надеюсь  что более или менее понятно, разобрались с</C2>
<C2> загрузкой  и  структурой исполняемых  файлов.   Таким  образом,  подошло время</C2>
<C2> рассказать о самом дурацком, но и наиболее простом способе инфицирования. </C2>

<C2>    Способ  этот  заключается в дописывании (</C2>link<C2>) своих данных в первую секцию</C2>
<C2> записи исполняемого файла на диске, с последующим изменением последней команды</C2>
<C2> возврата (</C2>rts<C2>) на команду перехода на тело вируса (</C2>bra.b адрес_тела_вируса<C2>). </C2>

<C2>    Конечно, этот способ имеет множество недостатков. Например, то, что имеется</C2>
<C2> вероятность  так  дописать свои данные в секцию кода, что мы рискуем вообще не</C2>
<C2> добраться  до команды возврата, или то, что первой секцией может оказаться</C2> bss
<C2> (тогда  мы  просто много чего попортим).  Однако эти недостатки компенсируются</C2>
<C2> простотой   реализации,   а  посему  "линкующихся"  вирусов  написано  великое</C2>
<C2> множество. Алгоритм же действий при этой технологии будет таким:</C2>


    1) <C2>открываем файл, который будем инфицировать.</C2>

    2) <C2>узнаём  из  </C2>3<C2>-го  поля  заголовка количество  секций и в зависимости  от</C2>
       <C2>полученных  данных  переходим  на  секцию  кода  (прибавлением  величины</C2>
       <C2>таблицы </C2>memaloc_table<C2> к заголовку).</C2>

    3) <C2>из  заголовка  секции  мы  узнаём и запоминаем размер секции кода (чтобы</C2>
       <C2>знать где конец).</C2>

    4) <C2>изменяем  размер  секции  в секционном заголовке с учётом величины  кода</C2>
       <C2>тела нашего вируса.</C2>

    5) <C2>переходим  на  конец  секции,  дописываем  код нашего вируса  и начинаем</C2>
       <C2>искать команду возврата (</C2>rts<C2>).</C2>

    6) <C2>первую  же  найденную  команду возврата заменяем на команду перехода  на</C2>
       <C2>тело нашего вируса.</C2>

    7) <C2>сохраняем сделанные изменения и отпускаем файл.</C2>


<C2>    Более  продвинутый  способ.   Более  продвинутый  он  тем, что производится</C2>
<C2> добавление  новой,  первой  секции.   Соответственно,  придётся позаботиться о</C2>
<C2> изменении  содержимого  подсекции  </C2>reloc<C2>  и  смещении  исходных положений всех</C2>
<C2> секций исполняемого файла. Плюсов у этого способа, как минимум два:</C2>

    1) <C2>вирус выполняется перед самой программой. </C2>

    2) <C2>код  оригинальной  программы   не   изменяется,  поэтому  нет  и  ошибок</C2>
       <C2>контрольной суммы.</C2>

<C2>    Минус  состоит  в  том,  что  этим методом не получится заражать резидентов</C2>
<C2> (библиотеки,  хэндлеры,  и  т.п.),  поскольку  в  первой  секции  уже не будет</C2>
<C2> соответствующей им структуры. Если же очень хочется инфицировать и резидентов,</C2>
<C2> то встаёт задача добавления этой структуры в кодовую секцию вируса.</C2>

<C2>    Способов  заражения  существует  великое  множество.   Но,  так, или иначе,</C2>
<C2> большинство амижных вирусов построены на комбинировании двух методов описанных</C2>
<C2> выше.   В  качестве  примера  вышесказанного,  я  предлагаю Вам самостоятельно</C2>
<C2> разобрать  всем  известный  и  весьма  полезный (в образовательных, конечно же</C2>
<C2> целях) вирус </C2>B0bEK<C2>, написанный неким </C2>PANDAEMON<C2>'ом.</C2>


 <HREF "#BEG" alt=" > "> <B>ВЕРНУТЬСЯ В НАЧАЛО</B>

<C1>                 _,,             _,,             _,,         </C1>
<C1>                 "-.\=           "-.\=           "-.\=       </C1>
<C1>                   \\=   _.~       \\=   _.~       \\=   _.~</C1>
<C1>                  _|/||||)_       _|/||||)_       _|/||||)_ </C1>
<C1>                  \        \      \        \      \        \</C1>


<#005>
                        <C1>o  КАК ОСТАТЬСЯ РЕЗИДЕНТОМ ?  o</C1>


 <C2>    Напоследок,  я  вкратце расскажу о том, как пропатчить некоторые функции</C2>
 <C1>AmigaOS</C1><C2> оставшись при этом резидентом. Вот что для этого нужно:</C2>

  1)<C2> захватить необходимый кусок памяти  (наилучший/наиболее понятный способ  -</C2>
    <C2> использование функции </C2>AllocMem()<C2> ).</C2>

  2)<C2> скопировать тело вируса в захваченную память.  Здесь  очень важно очистить</C2>
    <C2> кэши перед переходом на новый адрес памяти. Самый простой способ:</C2>

        move.l   4.w,a6               <C2>; указатель на exec.library (execbase)</C2>
        jsr      _LVOCacheClearU(a6)  <C2>; очистили кэши</C2>

  3)<C2> патч  (изменение)  системных  функций.   Самый простой способ, это  просто</C2>
    <C2> изменение  библиотечных  векторов.  По идее, в другой операционной системе</C2>
    <C2> пришлось  бы  повозиться  (контрольные  суммы  и  иже с ними).  Но на наше</C2>
    <C2> счастье,  у  </C2><C1>AmigaOS</C1><C2>  есть  системная  функция,  которая  всё это делает -</C2>
     SetFunction()<C2>. Таким образом, в dos.library, например, мы можем пропатчить</C2>
     LoadSeg()<C2>,</C2>  Open()<C2>,</C2> Read()<C2>,</C2> Seek()<C2>,</C2> Examine() <C2>и т.д. (кстати, </C2>B0bEK<C2> помимо</C2>
     <C2>них, также патчит и функцию </C2>ExNext()<C2> из</C2> dos.library<C2>).</C2>

<C2>    Конечно же, даже самый убогий антивирус, отслеживает изменение библиотечных</C2>
<C2> векторов. Поэтому  способ, рассказанный выше, оказывается в этом плане слишком</C2>
<C2> простым  и  для  вируса он не подходит.  Здесь существуют и другие способы, но</C2>
<C2> вместо  того  чтобы  рассказывать  о них, я лучше расскажу о том, как  амижные</C2>
<C2> вирусы "выживают" после сброса компьютера. Рассмотрим самый популярный способ.</C2>
<C2> В  </C2><C1>AmigaOS</C1><C2>  изначально  заложен  ряд  возможностей,  которые  "играют на руку"</C2>
<C2> авторам-вирусописателям.   А  именно,  речь  идёт о точках входа exec, которые</C2>
<C2> установлены  для различных этапов загрузки системы: </C2>ColdCapture<C2>,</C2> CoolCapture<C2> и</C2>
 WarmCapture<C2>.   Обычно  они  установлены  в  </C2>0<C2>  (начало  памяти),  но некоторые</C2>
<C2> программы и большинство вирусов, модифицируют их и используют для своих целей.</C2>
<C2> Для  их изменения нужно вычислить</C2> execbase->ChkSum<C2> и система изменит указатель</C2>
 execbase<C2>  после  сброса  компьютера.   Для  вычисления контрольной суммы можно</C2>
<C2> использовать следующий код:</C2>


    move.l  4.w,a6          <C2>; указатель на </C2>exec.library<C2> (</C2>execbase<C2>)</C2>
    lea     SoftVer(a6),a0  <C2>; начало подсчета контрольной суммы структуры</C2>
    moveq   #0,d0
    moveq   #24-1,d1        <C2>; счётчик - контрольная сумма через  </C2>24<C2> слова</C2>
.l  add.w   (a0)+,d0        <C2>; добавляем слова</C2>
    dbf     d1,.l           <C2>; крутим цикл</C2>
    not.w   d0
    move.w  d0,(a0)              <C2>; перенос контрольной суммы в</C2> execbase->ChkSum
    jsr     _LVOClearCacheU(a6)  <C2>; очищаем кэши</C2>

<C2>    Этот способ настолько часто применялся в</C2> bootblock<C2>-вирусах, что у амижников</C2>
<C2> уже выработалось мнение о том, что данная их разновидность наиболее "живуча".</C2>


 p.S.<C2>   Надеюсь, что  материал, изложенный  в  этой  статье, поможет начинающим</C2>
     <C2> системным  программистам.   Надеюсь,  что  и  не только им.  Если реакция</C2>
     <C2> читателей на эту статью будет положительной, если статья вызовет интерес,</C2>
     <C2> то  у  автора,  в  свою  очередь, не возникнет проблем с её продолжением.</C2>
     <C2> Отдельное  спасибо  полякам за помощь в подготовке материала, в частности</C2>
      Beol^XiNE#2<C2>,</C2> Mandrogger^Epidemic<C2> и конечно же</C2> GuruBook<C2>.</C2>
 
                                                                          <C1>CI A.</C1>

 <HREF "#BEG" alt=" > "> <B>ВЕРНУТЬСЯ В НАЧАЛО</B>

<C1>                 _,,             _,,             _,,         </C1>
<C1>                 "-.\=           "-.\=           "-.\=       </C1>
<C1>                   \\=   _.~       \\=   _.~       \\=   _.~</C1>
<C1>                  _|/||||)_       _|/||||)_       _|/||||)_ </C1>
<C1>                  \        \      \        \      \        \</C1>


<C1><B>                _  _      _  _     _       _  _      _  _  _ _</B></C1>
<C1><B>               (-'(_)(/\)(_'( '   (-)(\/)|(_;(-)  ;  (_(_)(_)/)</B></C1>



