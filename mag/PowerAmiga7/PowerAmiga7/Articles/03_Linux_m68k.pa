<#BEG>

                     XXX    XXX XXXXXXx  XXX  XXX XXX  XXX
<C1>                     XXX     XX XXX xXXX XXX  XXX XXX  XXX</C1>
<C1>                     XXX     XX XXX  XXX XXX  XXX XXX  XXX</C1>
<C2>                     YYY     YY YYY  YYY YYY  YYY  YYYYYY </C2>
<C2>                     YYY     YY YYY  YYY YYY  YYY   YYYY  </C2>
<C1>                     !!!     !! !!!  !!! !!!  !!!  !!!!!! </C1>
<C1>                     !!!  !: !: !!!  !!: !!!  !!: !!!  !!:</C1>
                     ;;;;;;; ;; ;;;  ;;;  ;;;;;;; ;;;  ;;;


          <B><C1>. . .  ПРОГРАММИРОВАНИЕ НА АССЕМБЛЕРЕ m68k ПОД LINUX  . . .</C1></B>

 (ц) Егор Егоров aka madcr
 email: madrats@mail.ru


<C2>    Данной   статьей   хотелось   бы   начать  некий  цикл  статей  посвященный</C2>
<C2> программированию   на   ассемблере   под  </C2>Unix<C2>-подобные  </C2>OS<C2>,  которые  отлично</C2>
<C2> функционируют  на  старых  добрых амигах.  Ориентироваться для начала будем на</C2>
 m68k<C2>  процессор.   В будущем, если появятся доброжелательные отклики, и кто-то</C2>
<C2> пожелает увидеть продолжение такого рода статей (основанных не только на </C2>m68k<C2>,</C2>
<C2> но  и  на </C2>mс88<C2>,</C2> PPC<C2>), то эти продолжения, я надеюсь, будут появляться в каждом</C2>
<C2> последующем выпуске журнала.</C2>

                                                                  / ОТ АВТОРА /




               ,        ,
              /(        )`
              \ \___   / |        [<HREF "#001" alt=" 1 ">] <C2>ВВЕДЕНИЕ И ТЕОРИЯ</C2>
              /- _  `-/  '
             (/\/ \ \   /\
             / /   | `    \       [<HREF "#002" alt=" 2 ">] <C2>ГРАФИКА</C2>
             O O   ) /    |
             `-^--'`<     '
            (_.)  _  )   /
             `.___/`    /
               `-----' /
  <----.     __ / __   \
  <----|====O)))==) \) /====
  <----'    `--' `.__,' \
               |        |
                \       /
           ______( (_  / \______
         ,'  ,-----'   |        \
         `--{__________)        \/


<#001>
                            <B><C1>o  ВВЕДЕНИЕ И ТЕОРИЯ  o</C1></B>


<C2>    На   данный   момент   под   </C2>Amiga<C2>  существует  порядка  десятка  различных</C2>
 Linux<C2>/</C2>Unix<C2>-клонов  (</C2>BSD<C2>-ветки,  </C2>Unix<C2>-клоны,  </C2>DG-UX<C2>  и т.д.), но мы, для начала</C2>
<C2> рассмотрим  официально поддерживающий Amiga дистрибутив </C2>Debian/m68k GNU/Linux<C2>.</C2>
<C2> Взять  его  можно  с  официального сайта  <HREF "#http://www.debian.org" alt="http://www.debian.org"> и проблем с его</C2>
<C2> установкой  возникнуть  не  должно,  так  как все сводится к запуску amiboot с</C2>
<C2> указанием в аргументе запакованного образа ядра и некоторых других параметров.</C2>
<C2> Весь   процесс   инсталляции   дистрибутива   на  Amiga  подробно  расписан  в</C2>
<C2> многочисленных  руководствах  посвящённых  </C2>Debian<C2>,  причём  на  русском языке.</C2>
<C2> Если  говорить  о  производительности,  то  на  060/66.5MHz  мы  имеем  133.12</C2>
<C2> bogomips, чего хватает, мягко говоря, на все (030/50MHz на A1200 без FPU, но с</C2>
<C2> MMU  для решения задач, которым посвящена данная статья, хватает за глаза и за</C2>
<C2> уши  -  прим.   технического редактора).  Проблему с видео обошел хитрый поляк</C2>
<C2> написавший  framebuffer  для  </C2>AGA<C2>  (который, кстати, мы будем использовать при</C2>
<C2> работе  с  графикой).   Естественно,  что  в  свете развития платформы, </C2>AGA<C2> не</C2>
<C2> является  оптимальным решением как видео-чип, для чего и написаны драйвера под</C2>
<C2> видеокарты  </C2>CyberVision<C2>,  </C2>Retina<C2>,  </C2>Helfrich<C2>,  </C2>Piccolo<C2>  и  т. д..  Сравнительно</C2>
<C2> недавно  мне посчастливилось пообщаться с неким </C2>Adam Kowalczyk<C2> который написал</C2>
<C2> драйвер   для   </C2>Mediator4000/Voodoo3<C2>   и  обещался  доделать  аналогичный  для</C2>
 Mediator1200/Voodoo3<C2>.   Вообще  же,  технические  характеристики  и  различные</C2>
<C2> методы решения аппаратных проблем, это довольно интересная и обширная тема, но</C2>
<C2> наша статья нацелена слегка на другое, с чего и начнем.</C2>

     
<C2>    Итак,  для  начала  необходимо  выбрать  и  разобраться  с  компилятором  и</C2>
<C2> линковщиком.  По умолчанию во всех дистрибутивах *unix присутствует компилятор</C2>
 as <C2>соответствующий синтаксическому стандарту </C2>AT<C2>&</C2>T<C2> (довольно похожему на родной</C2>
<C2> Devpac'овский).   Его  и  будем  использовать,  т.к.   inline-ассемблер  в </C2>gcc
<C2> (родной  компилятор  </C2>C++<C2>) имеет точно такой же синтаксис, плюсы чего очевидны.</C2>
<C2> Рассмотрим некоторые особенности синтаксиса </C2>AT<C2>&</C2>T<C2>:</C2>

 
  1. Перед регистрами всегда ставится знак '%'. (%ebp,%eax).
  2. Перед непосредственными операндами символ '#'. (pea #1).
  3. Директивы всегда начинаются с точки (.text,.data)
  4. Если после каких-то символов стоит двоеточие - то это метка.


<C2>    К командам имеющие операнды добавляются такие суффиксы:</C2>

      СУФФИКС  ОПИСАНИЕ   ОБРАЗЕЦ
    
      <C1>b</C1>        <C1>1</C1> <C2>байт</C2>     movb #1,%d0
      <C1>w</C1>        <C1>2</C1> <C2>байта</C2>    movw #1,%d0     
      <C1>l</C1>        <C1>4</C1> <C2>байта</C2>    movl #0x11111111,%d0

      и т.д.


<C2>    Самые необходимые секции:</C2>

 .data    - секция данных
 .text    - секция кода
 .asciz   - строка ascii символов оканчивающаяся нулем
 .globl   - глобальная метка
 .include - подключение файла
 .macro   - макрос
 .byte    - возможность писать ОП-коды инструкций и просто байты.
  

<C2>    Вообще,  лучше  всего почитайте документацию по </C2>as<C2> (она доступна, например,</C2>
<C2> на <HREF "#http://ufalug.rb.ru/docs/gas/gas.html" alt="http://ufalug.rb.ru/docs/gas/gas.html">), но если такой возможности нет, то я</C2>
<C2> надеюсь, что моё краткое вводное объяснение синтаксиса вам поможет.</C2>


<C2>    Линковщиком является </C2>ld<C2>, описывать который нет смысла, т.к.  в нашем с вами</C2>
<C2> случае, его применение будет довольно простым.</C2>


<C2>    Итак,  теперь,  когда  мы разобрались с синтаксисом, настало время написать</C2>
<C2> классический </C2>hello world<C2>. Писать под </C2>unix<C2> на ассемблере можно 2-мя путями:</C2>

    1. С использованием библиотечных функций.
    2. С использованием системных вызовов.


<C2>    В   первом   случае,   нам  придётся  использовать  функции  из  библиотек.</C2>
<C2> Библиотеки уже оснащены обработчиками ошибок, функциями </C2>prologue<C2> и естественно</C2>
<C2> работают   чуть   медленнее,  чем  системные  вызовы.   Плюс ко  всему, размер</C2>
<C2> исполняемого  файла  в  этом  случае  получится значительно больше, нежели при</C2>
<C2> использовании системных вызовов.</C2>
 
<C2>    Во  втором  случае,  мы  напрямую  работаем  с системными вызовами, которые</C2>
<C2> являются  низкоуровневым сервисом, предоставляемым ядром. Схематично, доступ к</C2>
<C2> "железу" можно представить следующим образом:</C2>

                            ­ЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЇ
			    ў библиотеки/функции  ў
                            ЄЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎҐ
                            ў  системные вызовы   ў
                            ЄЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎҐ
                            ў                     ў
                            ў         ядро        ў
                            ў                     ў
                            ЄЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎҐ
                            ў аппаратный контроль ў
                            їЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎґ

<C2>    В том случае, когда мы пишем с использованием вызовов библиотечных функций,</C2>
<C2> мы  можем пользоваться обычными </C2>C<C2>-функциями (такими, как:  </C2>printf<C2>,</C2> open<C2>, </C2>close
<C2> и    т.д.,   описание   которых   можно   посмотреть   практически   в   любом</C2>
<C2> учебнике/справочнике    по    </C2>C<C2>/</C2>C++<C2>,    т.к.     </C2>С<C2>    -   само   олицетворение</C2>
<C2> кросплатформенности).   В  случае же с системными вызовами мы можем посмотреть</C2>
<C2> список (и номера) системных вызовов в </C2>/usr/include/asm/unistd.h

 
<C2>    Напишем 2 примера, чтобы оценить оба варианта:</C2>

 1. Использование библиотечных функций.

<C2>       Подход  в  этом  случае будет таким:  аргументы заносятся в стек и затем</C2>
<C2>    вызывается  функция.  После вызова, стек необходимо очистить от аргументов.</C2>
<C2>    Помимо  этого, мы обязательно должны начинать код с метки </C2>main<C2> (особенность</C2>
<C2>    использования библиотек). </C2>

<C2> Пример:</C2>


 .globl main
 main:
 .text
         pea buffer       /* аргумент заносится в стек */
         jbsr printf      /* происходит вызов библиотечной функции */
	 addq.l #4,%a7    /* стек очищается */
	 rts              /* выход */

 .data
 buffer: .string "Hello amigiаns from Amiga Linux!..\n"


<C2>    В  такой  реализации  программы,  мы можем воспользоваться </C2>as<C2> и </C2>ld<C2>, а можем</C2>
<C2> и сразу </C2>gcc<C2> (он уже сам разберется, что компилировать, а что линковать):</C2>
 
 # gcc hello_lib.s -o hello_lib
 # ./hello_lib
<C2> Hello amigians from Amiga Linux</C2>
 #



 2. Использование системных вызовов.
 
<C2>       Подход  в  этом  случае  будет  таким:   в  регистр  %d0 заносится номер</C2>
<C2>    системного  вызова  (смотреть  файл </C2>/usr/include/asm/unistd.h<C2>).  В регистры</C2>
<C2>    %d1,  %d2,  %d3 и т.д.  - аргументы.  Иногда требуется положить аргументы в</C2>
<C2>    стек и затем в один из регистров занести адрес, с которого они расположены.</C2>
<C2>    Вызов завершается  инструкцией  trap #0, которая и будет ссылаться на адрес</C2>
<C2>    входа  в  ядро,  во время исполнения программы (механизм исключений линейки</C2>
<C2>    процессоров </C2>m68k<C2>). Код обязательно должен начинаться с метки </C2>_start<C2>.  </C2>

<C2> Пример:</C2>

 
 .globl _start
 _start:

 .text

       movl #1,%d1        /* указывается поток stdout  */
       movl #buffer,%d2   /* указатель на выводимые данные */
       movl #30,%d3       /* длина данных */
       movl #4,%d0        /* заносится номер системного вызова 'write' */
       trap #0            /* происходит исключение */

       movl #1,%d0        /* заносится номер системного вызова 'exit' */
       trap #0            /* происходит исключение */
    
 .data
 buffer: .string "Hello amigos from Amiga Linux\n"
 

<C2> Для компиляции и линковки воспользуемся as и ld напрямую:</C2>

 # as hello_sys.s -o hello_sys.o
 # ld hello_sys.o -o hello_sys
 # ./hello_sys
<C2> Hello amigos from Amiga Linux</C2>
 #


<C2>    Если  говорить  именно о выводе </C2>ASCII<C2>-информации на экран, то надо сказать,</C2>
<C2> что  способов для реализации этого под </C2>Linux<C2>, существует превеликое множество.</C2>
<C2> Например,  у кодеров пользуется большой популярностью вывод не через </C2>stdout<C2>, а</C2>
<C2> непосредственно через файл псевдо-терминала </C2>/dev/tty<C2>.</C2>

<C2> Пример:</C2>


 .globl _start
 _start:

 .text

       movl #dev_tty,%d1  /* указатель на данные пути к устройству */
       movl #0xc02,%d2    /* указывается открытие в режиме чтения и записи */
       movl #5,%d0        /* заносится номер системного вызова 'open' */
       trap #0            /* происходит исключение */

       movl %d0,%d1       /* из %d0 берётся возвращённый вызовом указатель
                             на открытый файл */ 
    
       movl #buffer,%d2   /* указатель на выводимые данные */
       movl #30,%d3       /* длина данных */
       movl #4,%d0        /* заносится номер системного вызова 'write' */
       trap #0            /* происходит исключение */

       movl #1,%d0        /* заносится номер системного вызова 'exit' */
       trap #0            /* происходит исключение */
    
 .data
 buffer:  .string "Hello amigos from Amiga Linux\n"
 dev_tty: .string "/dev/tty1"


 # as hello_tty.s -o hello_tty.o
 # ld hello_tty.o -o hello_tty
 # ./hello_tty
<C2> Hello amigos from Amiga Linux</C2>
 #

 
<C2>    Я  думаю,  что самым простым способом освоить изложенное выше будет попытка</C2>
<C2> начать  писать  свои  первые  программы  под </C2>Linux<C2>, как используя оба подхода,</C2>
<C2> библиотечные  функции  и  системные  вызовы вперемешку.  Для этого потребуется</C2>
<C2> обозначать начало кода меткой </C2>main<C2> и компилировать его посредством </C2>gcc<C2>.  А уже</C2>
<C2> после   получения   положительных   результатов,   можно   начать   заниматься</C2>
<C2> оптимизацией - заменой всех вызовов библиотечных функций на системные вызовы и</C2>
<C2> т.п..</C2>

 <HREF "#BEG" alt=" > "> <B>ВЕРНУТЬСЯ В НАЧАЛО</B>

                 _,,             _,,             _,,         
                 "-.\=           "-.\=           "-.\=       
                   \\=   _.~       \\=   _.~       \\=   _.~
                  _|/||||)_       _|/||||)_       _|/||||)_ 
                  \        \      \        \      \        \



<#002>
                                 <B><C1>o  ГРАФИКА  o</C1></B>
 

<C2>   Какие  выводы  можно  сделать из предыдущей главы?  В первую очередь, должно</C2>
<C2> стать  понятно,  что,  занимаясь  программированием  на  ассемблере под </C2>Linux<C2>,</C2>
<C2> крайне  нежелательно  использовать  жёстко  зависимое  железо, а желательно по</C2>
<C2> максимуму  писать весь код под систему.  Такой подход избавит вас в будущем от</C2>
<C2> проблем  с  совместимостью  (например, с дистрибутивами </C2>Linux<C2> на Mac и Atari -</C2>
<C2> прим.   редакции).   Поэтому  из всех возможных методов, я выбрал (для начала)</C2>
<C2> вывод  графики  через Frame Buffer, который можно в принципе назвать более или</C2>
<C2> менее  системным.   Установленный  в  системе  Frame  Buffer  (например, пакет</C2>
 xserver-fbdev_3.3.6-11potato32.deb <C2>  -  прим. редакции)  доступен  через  файл</C2>
<C2> устройства </C2>/dev/fb<C2>, являющейся ссылкой на видео-часть компьютера. Безразлично,</C2>
<C2> что  она  собой  представляет  - чипсет </C2>AGA<C2>  или  видеокарту.  Таким  образом,</C2>
<C2> используя Frame Buffer мы можем получить аппаратно-независимый код.</C2>

<C2>    Алгоритм работы с Frame Buffer следующий:</C2>
 
<C1> -- activation (активация)</C1>
   
    1. <C2>  Устанавливается  графический  kd-режим.  В этом же режиме, кстати, при</C2>
       <C2>загрузке  и  выводится  тот  самый  пингвин.   Можно,  конечно, выводить</C2>
       <C2>графику и в </C2>text kd mode<C2>, но в этом случае глаза будут мозолить курсоры,</C2>
       <C2>поэтому  придется  выполнять самостоятельную очистку экрана и решать ещё</C2>
       <C2>ряд  связанных  с  этим проблем.  Установка производится через системный</C2>
       <C2>вызов "</C2>ioctl<C2>".</C2>

    2. <C2>Открывается файл устройства </C2>/dev/fb0<C2>.</C2>

    3. <C2>  Делается  mapping  (здесь, запрос на выделение.  Синонимы - allocate,</C2>
       <C2>захват  -  прим.   редакции)  видеопамяти  нужного  размера  посредством</C2>
       <C2>системного  вызова  "</C2>mmap<C2>"  (либо  одноименной функции) через полученный</C2>
       <C2>указатель на открытый файл устройства </C2>/dev/fb0<C2>.</C2>

 
<C1>  -- deactivation (деактивация)</C1>

    1. <C2>Восстановление режима </C2>kd text mode<C2>. </C2>

    2. <C2>По необходимости закрывается файл устройства </C2>/dev/fb0<C2>.</C2>

    3. <C2>UnMapping видеопамяти (системный вызов "munmap").</C2>
  
 
<C2>    Рассмотрим банальный пример вывода пикселя в видеорежиме 640x480x256 (Frame</C2>
<C2> Buffer при этом функционирует на </C2>AGA<C2>):</C2>

 .globl _start             /* код будет написан чисто системными вызовами */
 _start:       

 .text                     /* начало кода */

<C1> # Устанавливается режим "graphics kd". Параметры для установки и номера </C1>
<C1> # режимов определены в файле /usr/include/linux/kd.h</C1>
<C1> # Использован системный вызов "ioctl"</C1>

         movl #54,%d0      /* номер системного вызова "ioctl" */
         movl #0,%d1       /* поток stdin */
         movl #0x4b3a,%d2  /* kdsetmode (/usr/include/linux/kd.h) */
         movl #1,%d3       /* идентификатор 1 - kd graphics режим */ 
         trap #0


<C1> # После того как режим установлен, необходимо открыть файл /dev/fb0 (т.е.</C1>
<C1> # Frame Buffer) и попросить систему выделить необходимый кусок видеопамяти.</C1>
<C1> # После выполнения вызова "mmap", в регистре %d0 будет возвращён указатель</C1>
<C1> # на выделенную видеопамять, с которой мы уже сможем работать.</C1>

<C1> # mmap(0,VMEM_SIZE,PROT_READ|PROT_WRITE,MAP_SHARED,open("/dev/fb0",O_RDWR)0);</C1>
<C1> # open:</C1>
        /* указатель на файл /dev/fb0 возвращается в %d0 */

	 movl #fb_dev_name,%d1     /* /dev/fb0 файл */
	 movl #2,%d2               /* аргументы системного вызова "open" */ 
         movl #0,%d3               /* аргументы системного вызова "open" */
         movl #5,%d0               /* системный вызов open */
	 trap #0

<C1> # mmap</C1>
<C1> # аргументы сначала соберем в стеке, и положим в %d1 адрес этих аргументов.</C1>

         movl #0,%sp@             /* 0 */
         movl #307200,%sp@(0x4)   /* просим нужный кусок памяти для 640x480 */ 
         movl #3,%sp@(0x8)        /* prod_read | prot write */    
         movl #1,%sp@(0xc)        /* 1 - MAP_SHARED */     
         movl %d0,%sp@(0x10)      /* указатель на /dev/fb0 */     
         movl #0,%sp@(0x14)       /* 0 */

         movl %sp,%d1             /* аргументы в %d1 */
         movl #90,%d0             /* вызов 'mmap' */ 
         trap #0

         movl %d0,video_handler   /* сохраняется указатель на видеопамять */
         movl video_handler,%a0   /* положим в %a0 */

<C1> # очистка экрана:</C1>
 
         movl #640*480-3,%d1      /* цикл по всему экрану */
 clear:  addl #1,%a0              /* очищаем по одному пикселю */                 
	 movl #0,(%a0)            /* вывод */
	 subl #1,%d1              /* уменьшение цикла */
	 cmpl #1,%d1                                     
	 bne clear                /* цикл */

<C1> # вывод пикселя:</C1>
        
         movl video_handler,%a0
   /* координаты, цвет (не забываем, что в нашем пример чипсет 'aga') */
	 addl #50026,%a0
 	 movl #1,(%a0)         
	

<C1> # ожидание нажатия 'enter'. Для этого воспользуемся вызовом "select" (142)</C1>
<C1> # определения и описания структур находятся в /usr/include/sys/time.h </C1>

 key_pressed:
         movl #1,%sp@  
	 movel %sp,%d2 
	 movel #0,%d3          /* FD_ZERO */
	 movel #0,%d4          /* FD_SET  */ 
	 movl #0,%sp@(0x4)     /* структура timeval */  
	 movl #50000,%sp@(0x8) /* структура timeval */    
	 movl #1,%sp@(0xc)     /* структура timeval */  
	 movl %sp,%d5          /* адрес аргументов в регистре %d5 */
         movl #142,%d0         /* системный вызов 'select' */
	 movl #1,%d1           /* STDIN + 1 */
	 trap #0

	 cmpl #1,%d0      /* если не "enter" */
	 bne key_pressed  /* то пока не выходим */

<C1> # exit:</C1>
<C1> # set 'text kd mode'</C1>
<C1> # и восстанавливаем режим text kd:</C1>

        movl #54,%d0      /* системный вызов "ioctl" */
        movl #0,%d1       /* поток stdin */
        movl #0x4b3a,%d2  /* kdsetmode (/usr/include/linux/kd.h) */
        movl #0,%d3       /* идентификатор 0 - text kd режим */ 
        trap #0
            
        movl #1,%d0        /* системный вызов "exit2" */
        trap #0

 .data
 fb_dev_name: .string	"/dev/fb0"
 video_handler: .long 0


<C2>    Компиляция все также тривиальна:</C2></C2>

 # as put_pixel.s -o put_pixel.o
 # ld put_pixel.o -o put_pixel


<C2>    Тот  факт,  что  приведённый  мной  пример  использует  для  вывода графики</C2>
<C2> разрешение  640x480,  на  самом  деле  не  имеет никакого значения.  Вы можете</C2>
<C2> установить  для  </C2>Linux<C2>  любое  разрешение  и  на  любом устройстве.  Это можно</C2>
<C2> сделать  либо  оперируя аргументами amiboot осуществляющего предзагрузку, либо</C2>
<C2> командой </C2>fbset<C2> из уже загруженного </C2>Linux<C2>.</C2>

<C2>    Предвидя  вопросы, которые могут возникнуть у читателей, расскажу вкратце о</C2>
<C2> выводе  полноценных спрайтов.  Это очень просто.  Подготавливается спрайт, как</C2>
<C2> raw-изображение  и в наглую копируется на Frame Buffer (другими словами, вывод</C2>
<C2> в файл </C2>dev/fb<C2>). Т.е. пройдёт даже команда:</C2>

 # cat mypicture.raw >/dev/fb0

<C2>    На  ассемблере  это  занимает,  тем  более, пару строчек.  Всё остальное, в</C2>
<C2> принципе,  уже  частности.   Даже  на  основе  данных выше примеров, можно уже</C2>
<C2> начинать   писать  свой  движок  для  игры  или  demo.   Чего  в  этой  статье</C2>
<C2> действительно   не   хватает,  так  это  описание  работы  с  файлом  </C2>/dev/dsp
<C2> (аналогично Frame Buffer, </C2>/dev/dsp<C2> - драйвер устройства обрабатывающего звук).</C2>
<C2> Но  я  надеюсь,  вернутся  к  этому  вопросу  в  следующих  номерах журнала. В</C2>
<C2> приложении  к седьмому номеру можно найти исходники всех программ этой статьи.</C2>
<C2> Если  данная  статья  вызовет читательский отклик, то можно впоследствии можно</C2>
<C2> будет рассмотреть и другие вопросы. Такие как, работа звук, CIA, другие методы</C2>
<C2> вывода графики на </C2>m68k<C2>/</C2>mc88<C2>/</C2>PPC<C2> процессорных линейках.</C2>

    CI A

 <HREF "#BEG" alt=" > "> <B>ВЕРНУТЬСЯ В НАЧАЛО</B>

 
<B><C1>                _  _      _  _     _       _  _      _  _  _  _</C1></B>
<B><C1>               (-'(_)(/\)(_'( '   (-)(\/)|(_;(-)  ;  (_(_)(_)'/)</C1></B>



