
      $   $$$$    $   $        $   $$$$    $   $        $   $$$$    $   $ 
     $$  $$  $   $$  $$       $$  $$  $   $$  $$       $$  $$  $   $$  $$  
    $ $   $$    $$  $$       $ $   $$    $$  $$       $ $   $$    $$  $$   
   $$$$    $$  $ $ $ $      $$$$    $$  $ $ $ $      $$$$    $$  $ $ $ $   
  $   $ $  $$ $  $$  $     $   $ $  $$ $  $$  $     $   $ $  $$ $  $$  $   
 $$   $ $$$$ $$  $  $$ ,  $$   $ $$$$ $$  $  $$ ,  $$   $ $$$$ $$  $  $$ . . .

                        <C1>. . .  ШКОЛА ПРОГРАММИСТА (II) . . .</C>

 Stas Piskunoff aka AcidRain/tPA (Краснодар)
 email: staspi#yandex.ru


 <C2>Каждый из  нас  видел  современные  демонстрации,  многие  восхищались  ими  и</C>
<C2>возможностями программистов, которые все это чудо создали. Сегодня редко, когда</C>
<C2>обходятся в демках, без применения так называемых 3D engine'ов (далее движков).</C>
<C2>Люди,  писавшие  такие  движки,  работали над ними не один день, месяц и, даже,</C>
<C2>год. Но чем  мы  хуже?  Собственно,  ни  чем.</C>

 <C2>В данной статье мы не будем углубляться во все премудрости и хитрости движков,</C>
<C2>а  приступим  к  изучению  и  пониманию  процедуры  прорисовки  полигона, но не</C>
<C2>"плоско-заполненого", а с использованием затенения. Т.е. полигон, на всей своей</C>
<C2>поверхности,  будет  иметь  разную  степень  освещенности. Существует несколько</C>
<C2>способов затенения полигона ( а вместе с ним и всего объекта, будь то  куб  или</C>
<C2>"робот-воин"  из  вашей  будущей  игры  ;), вот некоторые  из них. Затенение по</C>
<C1>Ламберту (Lambert)</C> <C2>и затенение по </C><C1>Гуро (Gouraud)</C><C2>, имеют такие названия в  честь</C>
<C2>их   "первооткрывателей".   Освещение   по  Ламберту  слишком  требовательно  к</C>
<C2>процессорному времени, т.к. содержит несколько делений и вычисление квадратного</C>
<C2>корня.   Да   и   реализация  его    сложнее,  чем  затенение  по  Гуро.</C>
<C2>Следовательно, мы рассмотрим последнее.</C>
                                                      
 <C2>Сама процедура прорисовки  затененного  полигона  не   намного   отличается  от</C>
<C2>процедуры рисования заполненого полигона. Напомню лишь основные моменты.</C>

 <C2>Рисуем треугольный полигон, для чего, сортируем координаты его вершин по  Y  от</C>
<C2>наибольшей  -  к наименьшей. Затем вычисляем длины каждой из его сторон </C>( x2-x1;
y2-y1; и т.д.)<C2>. Соотношение двух противоположных  ребер  треугольника  дает  нам</C>
<C2>ширину  скан-линии (количество  точек  в данной горизонтальной линии), а разница</C>
<C2>длин по </C>Y (y2-y1) <C2>дает нам высоту рисуемой секции. Закончив прорисовку линии  за</C>
<C2>линией  в  первой секции, переходим ко второй и рисуем ее аналогично предыдущей.</C>
<C2>Все, наш треугольник нарисован. Но как же нам  его  затенить?  Добавим  еще  два</C>
<C2>параметра, к уже существующим - </C><C1>(x1,y1); (x2,y2); (x3,y3); c1</C><C2>. Этими параметрами</C>
<C2>будут замеры величины света на каждой, из трех вершин - </C><C1>c2; c3</C><C2>. Теперь мы должны</C>
<C2>проинтерполировать   каждую   скан-линию  в  нашем  треугольнике  для  получения</C>
<C2>линейного затенения на всей поверхности полигона.</C>

 <C2>После немного занудной теории совсем чуть-чуть псевдо-кода,  объясняющего,  как</C>
<C2>рисовать простой, одноцветный полигон. Затем перейдем к Gouraud.</C>

; (x1,y1); (x2,y2); (x3,y3)  - <C2>координаты</C>
; color        - <C2>угaдайте что ;)</C>

<C1>draw_tri</C>
    ; сортируем координаты в порядке от большей к меньшей по Y;
    ...
    ; считаем дельты (длины);
    ...
    ; считаем высоту данной секции, для получения счетчика в Y-цикле;
    ; высота = y2-y1;
    ;
    ; если высота = 0, то просто переходим далее, на нижнюю часть;

    ; начало по y = y1

<C1>.yloop</C>    ; первая часть;
    ; текущий x1 = x1
    ; текущий x2 = x1        <C2>; не типично, есть над чем подумать ;-)</C>
    ;
<C1>.xloop</C>    ; сравниваем x1 и x2 
    ; всегда рисуем слева направо, так что x1 должен быть меньшим
    ; из двух существующих
    ; здесь же мы получаем цикл по X = x2-x1
    ; если ширина = 0, то можно пропустить, конечно же ;)

<C1>.xinner</C>  ; рисуем точки по x1-x2, здесь ничего не надо интерполировать
    ; потому что мы рисуем все точки одним цветом...
    ;
    ...

    ; скан-линия нарисована, считаем новое соотношени x1/x2 и идем ниже
    ; по y линии

    ; новая x1 = текущей x1+dxdy1
    ; новая x2 = текущей x2+dxdy3
    ; новая y     = y начальная + ширина экрана ;
    : повторяем Y цикл до тех пор, пока не будет достигнут 0
    ;


<C1>PART2</C>    <C2>; Первая часть готова, рисуем 2 и последнюю ;)</C>

    ; вычисляем высоту этой секции для Y цикла
    ; высота = y3-y2
    ;
    ; если высота = 0, то нечего рисовать больше ;)
    
    ; y начальная = y2

<C1>.yloop</C>    ; вторая часть
    ; текущий x1 = x2

    ;
<C1>.xloop</C>    ; сравниваем x1 и x2 
    ; необходимо, чтоб x был наименьшим из пары существующих
    ; x-цикл счетчик = x2-x1
    ; если ширина = 0  -   пропустим линию!

<C1>.xinner</C>    ; просто рисуем точки!
    ...

    ; скан-линия готова, переходим далее по Y

    ; новый x1 = текущий x1+dxdy2
    ; новый x2 = текущий x2+dxdy3
    ; новый y     = y начальный + ширина экрана
    : и так до нуля по Y
    ; rts :)

   <B> *** НАРИСОВАЛИ! ДОЛЖНЫ ВИДЕТЬ НА ЭКРАНЕ ОДНОЦВЕТНЫЙ ТРЕУГОЛЬНИК :) ***</B>



   <C2><B>*** ОДНОЦВЕТНЫЕ ТРЕУГОЛЬНИКИ - ОТСТОЙ! ИЛИ БЛИЖЕ К ГУРО ;) ***</B></C>

 <C2>В случае с Гуро, мы можем использовать 100% кода от предыдущей  процедуры,  нам</C>
<C2>придется  лишь  добавить  некоторые  крохи. Ранее  во внутреннем цикле мы просто</C>
<C2>выводили  точку  за  точкой   на  экран.  Теперь   нам   придется   в   x-loop'е</C>
<C2>интерполировать имеющиеся значения освещенности вершин.</C>

 <C2>Теперь вы можете спрашивать себя, а как получить эти значения? Немного  магии и</C>
<C2>мы  снова  на  коне  :D, мы их просто посчитаем. Есть несколько способов сделать</C>
<C2>это, но здесь  мы  применим  некоторое  приближение.  Это  приближение  является</C>
<C2>издевательским, но неплохо работает  для простых  трехмерных  объектов (куб). Мы</C>
<C2>просто используем нашу Z координату для получения цвета вершин. Но помните,  это</C>
<C2>не  является  натуральным  методом  затенения  по Гуро! Это приближение называют</C>
Z-shade<C2>.   Вам  придется  обрезать значение координаты Z, максимально  возможным</C>
<C2>цветом  палитры  -  <B>256</B>.   Но  неважно, как вы  сосчитаете значения освещенности</C>
<C2>вершин, главное  другое - процедура  рисования  полигона  с  затенением по  Гуро</C>
<C2>всегда <B>одинакова</B>!</C>

CHUNKYBUFFER <C2>указывает на наш экран, который мы заполним нашим убогим рисованием</C>
<C2>;)</C>

CHUNKYX = <C2>ширина экрана</C>
CHUNKYY = <C2>высота экрана</C>


<C1>*******************************************</C>
<C1>*** <B>Draw Gouraud-shaded Polygons</B>        ***</C>
<C1>*******************************************</C>
<C1>; требуется:</C>
<C1>; координаты в d0-d2</C>
<C1>; цвета в d3-d5</C>

<C1>; d0.l    (x1,y1)    d3.w    цвет 1</C>
<C1>; d1.l    (x2,y2)    d4.w    цвет 2</C>
<C1>; d2.l    (x3,y3)    d5.w    цвет 3</C>

<C1>Gouraud_Linear</C>

<C1>    cmp.w    d0,d2                </C><C2>; сортируем координаты</C>
<C1>    bge.b    .ok1</C>
<C1>    exg.l    d0,d2</C>
<C1>    exg.l    d3,d5</C>
<C1>.ok1    cmp.w    d1,d2</C>
<C1>    bge.b    .ok2</C>
<C1>    exg.l    d1,d2</C>
<C1>    exg.l    d4,d5</C>
<C1>.ok2    cmp.w    d0,d1</C>
<C1>    bge.b    .ok3</C>
<C1>    exg.l    d0,d1</C>
<C1>    exg.l    d3,d4
<C1>.ok3    </C>
 <C1>   lea    .VARS(pc),a6</C>
 <C1>   move.l    d0,.X1(a6)</C>
<C1>    move.l    d1,.X2(a6)</C>
<C1>    move.l    d2,.X3(a6)</C>
<C1>    move.w    d3,.C1(a6)</C>
<C1>    move.w    d4,.C2(a6)</C>
 <C1>   move.w    d5,.C3(a6)</C>


<C1>; считаем длины</C>
<C1>; dxdy1 = (x2-x1)/(y2-y1)</C>
<C1>; dcdy1 = (c2-c1)/(y2-y1)</C>
<C1>; dxdy2 = (x3-x2)/(y3-y2)</C>
<C1>; dcdy2 = (c3-c2)/(y3-y2)</C>
<C1>; dxdy3 = (x3-x1)/(y3-y1)</C>
<C1>; dcdy3 = (c3-c1)/(y3-y1)</C>


<C1>    move.w    .Y2(a6),d0            </C><C2>; считаем длину по Y</C>
<C1>    sub.w    .Y1(a6),d0</C>
<C1>    beq.b    .noDY1</C>
<C1>    move.w    .X2(a6),d1            </C><C2>; посмотрите</C>
<C1>    sub.w    .X1(a6),d1            </C><C2>; на формулы выше</C>
<C1>    ext.l    d1</C>
<C1>    lsl.l    #8,d1</C>
<C1>    divs.w    d0,d1</C>
 <C1>   move.w    .C2(a6),d2</C>
<C1>    sub.w    .C1(a6),d2</C>
<C1>    ext.l    d2</C>
<C1>    lsl.l    #8,d2</C>
<C1>    divs.w    d0,d2</C>
<C1>    ext.l    d1</C>
<C1>    ext.l    d2</C>
<C1>    move.l    d1,.DXDY1(a6)</C>
<C1>    move.l    d2,.DCDY1(a6)</C>

<C1>.noDY1    move.w    .Y3(a6),d0</C>
<C1>    sub.w    .Y2(a6),d0</C>
<C1>    beq.b    .noDY2</C>
<C1>    move.w    .X3(a6),d1</C>
<C1>    sub.w    .X2(a6),d1</C>
<C1>    ext.l    d1</C>
<C1>    lsl.l    #8,d1</C>
<C1>    divs.w    d0,d1</C>
 <C1>   move.w    .C3(a6),d2</C>
<C1>    sub.w    .C2(a6),d2</C>
<C1>    ext.l    d2</C>
<C1>    lsl.l    #8,d2</C>
<C1>    divs.w    d0,d2</C>
<C1>    ext.l    d1</C>
<C1>    ext.l    d2</C>
 <C1>   move.l    d1,.DXDY2(a6)</C>
<C1>    move.l    d2,.DCDY2(a6)</C>

<C1>.noDY2    move.w    .Y3(a6),d0</C>
<C1>    sub.w    .Y1(a6),d0</C>
<C1>    beq.b    .noDY3</C>
<C1>    move.w    .X3(a6),d1</C>
<C1>    sub.w    .X1(a6),d1</C>
<C1>    ext.l    d1</C>
<C1>    lsl.l    #8,d1</C>
<C1>    divs.w    d0,d1</C>
 <C1>   move.w    .C3(a6),d2</C>
<C1>    sub.w    .C1(a6),d2</C>
<C1>    ext.l    d2</C>
<C1>    lsl.l    #8,d2</C>
<C1>    divs.w    d0,d2</C>
<C1>    ext.l    d1</C>
<C1>    ext.l    d2</C>
<C1>    move.l    d1,.DXDY3(a6)</C>
<C1>    move.l    d2,.DCDY3(a6)</C>
<C1>.noDY3</C>

<C1>    <B>*** Верхняя часть треугольника ***</B></C>

<C1>    move.l    .DXDY3(a6),d6</C>
 <C1>   move.l    CHUNKYBUFFER(pc),a0</C>
<C1>    move.w    .Y1(a6),d0</C>
<C1>    mulu.w    #CHUNKYX,d0</C>
<C1>    add.l    d0,a0</C>

<C1>    move.w    .X1(a6),d0</C>
 <C1>   ext.l    d0</C>
<C1>    lsl.l    #8,d0</C>
<C1>    move.l    d0,a1</C>
<C1>    move.l    a1,a2</C>
<C1>    move.w    .C1(a6),d2</C>
<C1>    ext.l    d2</C>
<C1>    lsl.l    #8,d2</C>
<C1>    move.l    d2,a3</C>
<C1>    move.l    a3,a4</C>
    
<C1>    move.w    .Y2(a6),d7</C>
<C1>    sub.w    .Y1(a6),d7</C>
<C1>    beq.b    .next</C>
<C1>    subq.w    #1,d7</C>
<C1>.loopY    move.l    a1,d0        </C><C2>; x1 <<8</C>
<C1>    move.l    a2,d1        </C><C2>; x2 <<8</C>
<C1>    move.l    a3,d2        </C><C2>; c1 <<8</C>
<C1>    move.l    a4,d3        </C><C2>; c2 <<8</C>
<C1>    asr.l    #8,d0</C>
<C1>    asr.l    #8,d1</C>
<C1>    cmp.w    d0,d1</C>
<C1>    bge.b    .xok</C>
<C1>    exg.l    d0,d1</C>
<C1>    exg.l    d2,d3</C>
<C1>.xok    sub.w    d0,d1        </C><C2>; дельта x = ширине скан-линии</C>
<C1>    beq.b    .noX</C>

<C1>; dcdx = (c2-c1)/(x2-x1)</C>
<C1>    move.l    d3,d4</C>
<C1>    sub.l    d2,d4        ; c2-c1</C>
<C1>    divs.w    d1,d4        ; d4 = dcdy <<8</C>
<C1>    ext.l    d4</C>
<C1>    ror.l    #8,d4</C>
<C1>    move.l    d2,d5        ; c1 <<8</C>
<C1>    asr.l    #8,d5</C>
<C1>    lea    (a0,d0.w),a5</C>
<C1>.loopX    move.b    d5,(a5)+</C>
<C1>    addx.l    d4,d5        </C><C2>; интерполируем цвет</C>
<C1>    dbf    d1,.loopX

.noX    add.l    .DXDY1(a6),a1    </C><C2>; интерполируем x1</C>
<C1>    add.l    d6,a2        </C><C2>; интерполируем x2</C>
<C1>    add.l    .DCDY1(a6),a3    </C><C2>; интерполируем c1</C>
<C1>    add.l    .DCDY3(a6),a4    </C><C2>; интерполируем c2</C>
<C1>    lea    CHUNKYX(a0),a0</C>
<C1>    dbf    d7,.loopY</C>

<C1>    *** <B>Рисуем нижнюю часть</B> ***</C>


<C2> Практически совпадает с верхней, да  и  полезно  вам  будет  немного  "ручками"</C>
<C2>поработать  ;) На этом разрешите откланяться и пожелать вам одного - счастливого</C>
<C2>кодинга!</C>

p.S. Я выражаю огромную благодарность StingRay'ю из  Darkage^Scarab  -  без  его
помощи  я  не  был  бы  способен поделиться с вами, теперь уже моими знаниями ;)
<C2>.../\  ...</C>
<C2>     \/</C>
I wish to thank StingRay/DKG^Scarab. Without his help I'd not be able  to  share
with now my own knowledge of this problem ;-) Stingah! DankeSchone !
 
         <C2> .../\  ...^   ...</C>
          <C2>     \/     \/</C>
                _  _      _  _     _       _  _      _  _  _ _
               (-'(_)(/\)(_'( '   (-)(\/)|(_;(-)  ;  (_(_)(_)(_

