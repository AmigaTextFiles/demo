
                                   THE
                                  AMIGA
                               PROGRAMMERS
                                  GUIDE.

                            By C.J DITCHBURN
                             (V1.0 Edition)

         AMIGA A500 IS A REGISTERED TRADEMARK OF COMMODORE AMIGA INC.

                Translation by Zetter from Voronezh/Russia

                       ЧАСТЬ I: Внутренности А500.

                1. Введение.
                2. Процессор и чипсет.
                3. Конфигурация памяти.
                4. Управление DMA

                              1. Введение.

  Цель Путеводителя  программиста  -  дать  программисту  игр для Амиги
первый  шаг в написании игр. Он содержит простое описание железа и показывает,
как управлять этой мощной машиной.

  Главы, описывающие спрайты, аудио вывод, блиттер и многое другое дадут
читателю интуитивное представление о внутренней работе Амиги
  Языки программирования также обсуждены в последней главе, также описано, как
работать с железом в целом.

  Железо   -   сердце  машины,  и  для  наибольшей  производительности  должно
программироваться напрямую. Эта книга покажет Вам, как это делать.

  Путеводитель  программиста написан программистами игр для программистов игр,
но  если  Вы  хотите  прочитать  про  Амигу  или просто хотите иметь простое и
понятное описание железа - эта книга для Вас

                2. Процессор и чипсет

                2.1   Двоичные и шестнадцатиричные
                2.2   Процессор и регистры
                2.3   Agnus, Denise and Paula

  2.1   Двоичные и шестнадцатиричные

  Обычно  мы  пользуемся  десятичными числами. В них используется 10 цифр 0-9,
которые ставятся друг за другом для получения чисел
  Однако компьютер может использовать только 2 цифры для формирования чисел.
Эти   две   цифры   Вкл.  и  Выкл.,  что  соответствует  возможным  состояниям
электрических устройств

Двоичные цифры(биты) 0 и 1 комбинируются вместе в различные комбинации.

Используя 1 бит, возможны комбинации 0 и 1
Используя 2 бита, возможны комбинации 00,01,10 и 11
           (2 бита представляют 4 числа)

Подобным образом 8 бит дают 256 комбинаций и 256 возможных чисел (2^8=256)

Амига 16-ти битная машина, и может работать с числами 0-65535

группа из 8 бит=  байт
          16 бит= слово
          32 бит= длинное слово

Для иллюстрации этого приведем примеры нескольких байт:

           128    64    32    16    8    4    2    1
  5:        0     0     0     0     0    1    0    1      (4+1=5)

           128    64    32    16    8    4    2    1
 33:        0     0     1     0     0    0    0    1      (32+1=33)


(% - обозначение двоичного числа: %00100001=33)

 Двоичные  числа,  прекрасно  подходя  для  компьютеров,  слишком запутаны для
людей,   которым   сложно   понимать   строки   нулей   и  единиц.  Существует
компромиссное решение - шестнадцатиричная система

Шестнадцатиричная система (сокращенно HEX) использует 16 цифр, т.е. десятичные
0  - 15 рассматриваются как одна цифра. Цифры 0-9 имеют такое-же значение, что
и в десятичной системе, а вместо 10-15 используются буквы A-F

  HEX:  0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
  DEC:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15

  (Десятичное число 12 запишется как $C.)

  Для чисел больших 15, используются 2 hex цифры:

                              15 =  $0F
                              16 =  $10
                              17 =  $11
                              etc......
                              254 = $FE
                              255 = $FF

  Первая  цифра  определяет  коэффициент,  умножаемый  на 16, а второе - число
"единиц"

  Пройдем немного дальше, и используем 4 цифры

                              255 = $00FF
                              256 = $0100
                              257 = $0101
                              etc........
                             4096 = $1000
                            65535 = $FFFF

  Только с пониманием двоичной и шестнадцатиричной систем к Вам придет покой!

Амига  основана  на  серии  мощных  микропроцессоров  68000. Ранние процессоры
(такие как 6502) имели ограничения в использовании, поскольку у них был только
1  аккумулятор,  с  которым  процессор  выполняет  арифметические и логические
действия

68000 имеет 15 аккумуляторов, 8 из которых только для данных, а другие 7 - для
хранения адресов.

Полный список регистров 68000 показан ниже:

  8 DATA REGISTERS            -   32 BIT (D0-D7)
  7 ADDRESS REGISTERS         -   32 BIT (A0-A6)
  PROGRAM COUNTER             -   24 BIT (PC)
  2 STACK POINTERS            -   32 BIT (SP)
  STATUS REGISTER             -   16 BIT (SR)

Указатели  стека  используются  оба  - один программой пользователя, а другой-
операционной системой (USER/SUPERVISOR STACK POINTERS.)

Регистр  статуса  имеет  16  бит,  они  позволяют  узнать  результат последней
операции. Эти биты расположены так:

  15   14   13   12   11   10   9   8   7   6   5   4   3   2   1   0
  T    *    S    *    *    |    |   |   *   *   *   X   N   Z   V   C
                            2    1   0

  T   =   Бит режима трассировки
  S   =   Бит статуса супервизора
  |   =   Биты маски прерываний
   210
  X   =   Бит расширения
  Z   =   Флаг нуля
  N   =   Флаг отрицательного числа
  V   =   Флаг переполнения
  C   =   Флаг переноса

  24х   битный   программный   счетчик   указывает  на  следующую  выполняемую
инструкцию.  Его размер 2^24, т.е. 16,777,216 бит (16 Mb). PC может адресовать
в любое место в пределах 16Mb.

  2.2  Agnus, Denise and Paula

  Agnus содержит блиттер и DMA. Они будут объяснены позднее

  Denise  отвечает  за  графику  и  содержит  сопроцессор коппер. Также Denise
смотрит за спрайтами и мышкой (указатель мышки - спрайт)

  Paula  контролирует  4х  канальный  стерео  аудио  выход, и все хорошие игры
должны иметь качественный звук, тем более, что этому посвящена целая глава.

                3. Конфигурация памяти

                3.1  Карта памяти
                3.2  Чип память
                3.3  Память чипсета
                3.4  Область CIA
                3.5  Пример адресации регистров

3.1 Карта памяти

Как  упомянуто  ранее в главе 2.2, Амига имеет 16Mb адресного пространства (от
$000000 до $FFFFFF)

  Они распределены следующим образом:

  $000000-$07FFFF   Здесь расположены 512k Чип памяти
  $080000-$1FFFFF   Зарезервировано.
  $200000-$9FFFFF   8Mb для FAST памяти
  $A00000-$BFFFFF   Область CIA
  $C00000-$C7FFFF   512k Памяти расширений
  $C80000-$DFEFFF   Зарезервировано.
  $DF0000-$DFFFFF   Память регистров чипсета
  $E00000-$FFFFFF   Зарезервировано для ПЗУ

Программиста игр интересуют только следующие области:

  $000000-$07FFFF   Здесь расположены 512k Чип памяти
  $DF0000-$DFFFFF   Память регистров чипсета
  $A00000-$BFFFFF   Область CIA

Использование остальной памяти нецелесообразно

  3.2 Чип память ($000000-$7FFFFF)

  Это  область  памяти,  которую  могут  адресовать  сопроцессоры Амиги, ихние
программы и данные должны быть помещены туда.
  Амига   использует   динамическое   распределение   памяти,  любая   область
памяти  для любых данных (таких как коппер лист и данные спрайтов) должна быть
запрошена  у  системы,  а  затем  данные  должны  быть  скопированы  туда  или
перемещены прямым доступом.

   3.3 Память регистров чипсета ($DFF000-$DFFFFF)

  Для  управления  сопроцессорами  Амиги используется область памяти регистров
чипсета. Все эти регистры длиной одно слово и расположены по четным адресам
  На  самом деле используются лишь адреса $DFF000-DFF1BE, некоторые из которых
только для чтения, некоторые только для записи, и некоторые - регистры строба.

  Базовый  адрес  $DFF000,  и  регистры  адресуются смещением от этого адреса.
Некоторые   регистры  показаны  здесь,  но  все  значительные  регистры  будут
объяснены в соответствующих главах.

  BASE ADDRESS = $DFF000

  DMACON  -  $002      Регистр управления DMA
  JOYDAT0 -  $00A      Позиция Mouse/Joystick ( порт 0)
  COLOUR0 -  $180      Цветовой регистр 0 (цвет фона.)

  COP1LCH -  $080      Эти два регистра содержат адрес
  COP1LCL -  $082      первого копперлиста

3.4 Область CIA ($A00000-$BFFFFF)

  CIA  расшифровывается  как Complex Interface Adapter. В Амиге их два - CIA A
и CIA B.
  Они  содержат  таймеры  и счетчики событий, также по ним можно узнать статус
кнопок мыши и кнопки 'огонь' джойстика

3.5  Пример адресации регистров

  Регистры  лучше  всего адресовать поместив базовый адрес регистров чипсета в
любой  адресный  регистр,  и затем получать доступ к остальным регистрам через
него

  Для  примера,  положим цвет 0 (Черный) в регистр цвета фона ($180) следующим
образом:

  LEA $DFF000,a6           (базовый адрес в рег.a6)
  MOVE #$00,$180(a6)

  Также  возможно  записывать  в  два  регистра (такие как указатели на списки
данных) одновременно.
  Для  примера  COP1LCH  и  COP1LCL  ($080,$082)  содержат  19-ти битный адрес
первого  копперлиста,  разбитый  между ними. Одной записью можно их объединить
вместе:

  LEA $DFF000,a6
  MOVE .L copaddr,$80(a6)

  Т.к.  `copaddr'длиной  19  бит, нижние 16 бит лежат в $082, а верхние 3 - в
$080.

                4. Управление DMA

                4.1  Что такое DMA
                4.2  Использование DMA

  4.1  Что такое DMA

  DMA  расшифровывается  как  Прямой  Доступ  к  Памяти,  это  метод обработки
участков  памяти без использования процессора. В Амиге имеется контроллер DMA,
процессор  которого  смотрит  за  графикой,  звуком  и  доступом  к  диску без
вмешательства 68000.
  DMA  имеет  6  каналов  для  тех  областей,  которым необходим большой поток
данных  (например  блиттер),  но  для  простых  устройств, таких как джойстик,
канала не имеется, их обслуживает 68000

  Шесть   каналов   используются  для:  СПРАЙТОВ,  ЗВУКА,  КОППЕРА,  БЛИТТЕРА,
БИТПЛАНОВ и ДОСТУПА К ДИСКУ

  4.2 Использование DMA

  Каналы  DMA  запускаются  инициализацией   соответствующих  устройств.  Так,
инициализация канала коппера запускает коппер.
  Доступ  ко всем каналам идет через один регистр, DMACON, который доступен по
чтению по адресу $002, а по записи в $096

  16-ти  битный  регистр DMACON имеет следующую конфигурацию (установка бита в
1 включает соответствующее устройство DMA)

  Bits 0-3        Аудио каналы 0-3
  Bit 4           DMA диска
  Bit 5           DMA спрайтов
  Bit 6           DMA блиттера
  Bit 7           DMA коппера
  Bit 8           DMA битпланов
  Bit 9           DMAENABLE - если включен, включает все каналы
  Bit 10          BLTPRI - если включен, дает блиттеру приоритет над 68000.
  Bit 11          [UNUSED]
  Bit 12          [UNUSED]
  Bit 13          BZERO-(только чтение)- для операций с блиттером
  Bit 14          BBUSY-(только чтение)- для операций с блиттером
  Bit 15          бит ОЧИСТКИ/УСТАНОВКИ.

  Бит  15  в  DMACON  - специальный бит. Он должен быть 1 для включения других
битов,  т.е.  записав слово со включенными 7 и 15 битами (%1000000010000000) в
DMACON установим бит 7, включив DMA коппера
  Если бит 15 сброшен в 0, а бит 7 включен (%1000000010000000) то запись этого
слова в DMACON выключит коппер.

  Бит 9 должен быть установлен для открытия любого канала, независимо от того,
включается он или выключается. Если бит 9 ноль, все каналы выключаются

  Бит  10,  если  включен,  дает  блиттеру  больший приоритет чем процессору,
эффективно давая блиттеру приоритетный доступ в chip память во время работы

                ЧАСТЬ II: Программирование железа.

                5.  Коппер
                6.  Экраны и битмапы
                7.  Спрайты
                8.  Блиттер
                9.  Вывод звука
                10. Мышь, джойстик и прерывания

                5. КОППЕР

                5.1   Функции коппера
                5.2   Управление коппером
                5.3   Регистры коппера
                5.4   MOVE, WAIT и SKIP
                5.5   Пример копперлиста
                5.6   Пример программы

  5.1   Функции коппера

  Коппер  это графический сопроцессор, который как и 68000 выполняет программу
в  памяти.  Эта  программа  обычно  контролирует  позицию электронного луча на
мониторе и называется копперлист
  Копперлист  состоит из команд, размером в два слова и должен быть расположен
в chip памяти. На него также должны быть указатели.

  5.2  Управление коппером

  Копперлист может содержать три возможные команды:
  MOVE, WAIT и SKIP.

  MOVE: положить значение в регистр чипсета
  например  MOVE #2,$DFF00A   ;положить десятичное число 2 в $DFF00A.

  WAIT: дождаться достижения электронным лучом позиции x,y
  например:  WAIT (x,y)

  SKIP:  эта  команда  пропускает  следующую  команду  в копперлисте, если луч
достиг позиции x,y

  5.3 Регистры коппера

  Коппер имеет несколько прикрепленных регистров

  COP1LC  содержит  19-ти  битный  адрес  первого  адреса первого копперлиста,
разбит на COP1LCL и COP1LCH.

  COP1LCL = $DFF082 - нижние 16 из 19 бит.
  COP1LCH = $DFF080 - оставшиеся 3 бита.

  Также,     COP2LCH ($DFF084)
             COP2LCL ($DFF086)
  содержит 19-ти битный адрес второго копперлиста

  Эти  два  регистра  могут  быть записаны одной командой MOVE, как показано в
разделе 3.5

  Расположив  копперлисты  в  chip  памяти и установив ихние указатели COPLC,
можно запустить их на исполнение с помощью двух следующих регистров.

  COPJMP1  ($DFF088) и COPJMP2 ($DFFO8A) два триггера, или стробовых регистра,
запись в которые любого значения начинает выполнение копперлиста

  Адрес, содержащийся в COP1LC автоматически загружается в программный счетчик
коппера в начале каждого кадра.
  Отдельные   биты  регистра  COPCON  ($DFF02E)  могут  быть  установлены  для
разрешения копперу доступа к регистрам блиттера ($DFF040-$DFF07E).

  5.4  MOVE, WAIT и SKIP

  Эти команды занимают по два слова, каждый бит которых имеет свою функцию

  MOVE:
    Слово 1:Bit 0      Должен быть 0 для MOVE.
            Bits  1-8    Содержит адрес регистра - приемника для команды MOVE.
Только  8  верхних  бит  9-ти битового адреса задаются, поскольку бит 0 всегда
равен 0, то возможны только четные адреса

  Проще говоря, запись четного 9-ти битного адреса в первое слово команды MOVE
автоматически удовлетворяет формату команды.
            Bits 9-15 не используются.
    Слово 2:Bits 0-15 Содержат слово данных, которое будет записано.

WAIT:
                    Bit 0 Должен быть 1 для WAIT.
                    Bits 1-7 Содержит горизонтальную позицию луча.
                    Bits 8-15 Содержит вертикальную позицию.

                    Bit 0 Должен быть 0 для WAIT.
                    Bits 1-7 биты горизонтальной маски.
                    Bits 8-14 биты вертикальной маски.
                    Bit 15 бит BFD.

В  первом слове команды 8-ю битами определяется вертикальная позиция луча, что
дает 256 позиций (0-255).
Поскольку  полный  экран  содержит  313  возможных  позиций,  для  того, чтобы
дождаться позиций 256-313, сначала надо дождаться позиции 255

           например WAIT 0,255
                    WAIT 0.0     ;будем ждать до (0,256)

           and
                    WAIT 0,255
                    WAIT 0,30     ;будем ждать (0,286)

  Биты  1-7  содержат  верхние 7 бит 9-ти битовой горизонтальной позиции луча.
Два  первых  бита  зафиксированы  в  0,  следовательно  горизонтальная позиция
измеряется с шагом 4 пикселя (т.е. 0,4,8,12, и т.д.)

  Горизонтальное  разрешение  экрана  320  пикселей, а с 9 битами мы имеем 512
доступных позиций, это делает часть позиций недостижимыми.
  Ожидание недостижимой позиции заканчивает копперлист, и должно располагаться
в конце всех копперлистов.

  Биты  маски  во  втором  слове  предназначены  для  задания тех бит, которые
участвуют в сравнении
  Маска должна быть установлена в 1 для нормальной операции

  Бит  BFD  -  Blitter  Finish Disable, и если он 0, коппер будет всегда ждать
окончания  работы  блиттера  перед  началом  работы. Нормальное состояние - 1,
блиттер игнорируется.

  SKIP:
  Эта  команда  похожа  на  WAIT,  но  она  пропускает  следующую  команду при
достижении лучем заданной позиции

  e.g.       SKIP (X,Y)
             MOVE #$00,$180

  пропустит вторую команду, если позиция больше или равна (X,Y)

  Формат  команды такой же как и MOVE, исключая бит 0 во втором слове, который
для SKIP должен быть 1

  5.5 Пример копперлиста

  Следующая процедура устанавливает копперлист

  1. Запросить chip память для копперлиста
  2. Скопировать копперлист(или создать прямо в выделенной памяти)
  3. Выключить DMA коппера
  4. Записать адрес копперлиста в COP1LC
  5. Активизировать копперлист (записав в COPJMP1)
  6. Включить DMA коппера
  7. Подождать выхода, затем восстановить старый копперлист

  Реальный копперлист похож на это:

                   MOVE #$0000,$180
                   WAIT 15,160
                   MOVE #$FFFF,$180
                   WAIT 255,255

  Этот  пример  кладет  черный ($0000) в регистр цвета 0, ждет середины экрана
(15,160),  затем  меняет  его на белый ($FFFF). Ожидание (255,255) заканчивает
копперлист

  Парные слова конструируются так:

  MOVE #$0000,$180 = $180,$0000
  Биты  0-8  устанавливаются  в  первом слове на $180. Это также устанавливает
бит 0 в 0, что обозначает команду MOVE. (Биты 9-15 не используются.)
  Биты 0-15 во втором слове - $0000, это данные для перемещения.
  (Меняется порядок аргументов)

  WAIT(15,160) = $A00F,$FFFE
  Бит  0 в первом слове 1, как необходимо для WAIT, и биты 1-7 установлены как
15($0F)
биты 8-15 - 160($A0).
  Во втором слове все биты маски включены, и бит 0 =0 для WAIT

  Подобным образом,

                   MOVE #$FFFF,$180 = $180,$FFFF
                   WAIT(255,255) = $FFFF,$FFFE

  Итак, полный копперлист:

                   $180,$0000
                   $A00F,$FFFE
                   $180,$FFFF
                   $FFFF,$FFFE

Немного о том, почему позиция 15,160 а не 0, 160.
Это  потому  что  прорисовка  горизонтальной линии начинается с 15, что делает
позицию 0 примерно на дюйм правее правого края экрана.
  Все  изменения экрана желательно производить при невидимой экранной позиции,
это предотвратит появление проблем с синхронизацией

Горизонтальная позиция луча в диапазоне 0-227 ($00-$E3).
  With Horizontal Blanking gap 15-53.

Вертикальная позиция луча в диапазоне 0-312($00-$138)
  With Vertical Blanking gap 0-25.
Позиции луча могут быть прочитаны в VHPOS и VPOS.

VHPOS(чтение)($006)         VHPOS(запись)($02C)
VPOS(чтение)($004)          VPOS(запись)($02A)

VHPOS: биты 0-7 горизонтальная позиция луча (0-227)
       Bits 8-15 нижние 8 бит 9-ти битовой вертикальной позиции.

VPOS:  Bit 0  MSB 9-ти битовой вертикальной позиции.
       Bits 1-14 Не используется
       Bit 15 LOF (Длинный кадр) Используется при интерлейсе.

  Следующая программа устанавливает копперлист из предыдущей главы

  incdir  "include/"
  include "graphics/graphics_lib.l"

  *********ТРЕБУЕТСЯ СВОБОДНАЯ CHIP ПАМЯТЬ ДЛЯ РАЗМЕЩЕНИЯ КОППЕРЛИСТА********

  move.l $4,a6               ;Положим базовый адрес OS в a6
  moveq #size,d0             ;Размер копперлиста в байтах.
  moveq #2,d1                ;"2" определяет CHIP память.
  JMP -198(a6)               ;Это функция ALLOCMEM (смещение -198).
                              Ей   нужны  следующие  параметры  -  в  d0=
                              размер   необходимой   памяти   и  d1=тип памяти
                              (2=chip  память,$10002=chip  память ,заполненная
                              нулями.)

  move.l  d0,address           ;Адрес  выделенной  памяти  возвращается  в d0,
                                сохраняем в переменной `address'

  *КОПИРУЕМ КОППЕРЛИСТ ИЗ ПРОГРАММЫ В CHIP ПАМЯТЬ,С АДРЕСА `ADDRESS' *

  lea start,a0               ;Адрес копперлиста в программе.
  lea address,a1             ;Адрес куда копировать - в a1.
  moveq #size-1,d0           ;сколько байт копировать-1 = d0.
  loop move.b (a0)+,(a1)+
  dbf do,loop

  **************ВЫКЛЮЧАЕМ КАНАЛЫ DMA (коппер,битпланы)*******************

  lea $dff000,a5             ;базовый адрес регистров чипсета в a5.
  move.w #$0380,$96(a5)      ;96=DMACON.
  move.l #address,$80(a5)    ;Положили начало нового копперлиста в COP1LC($80).
  clr.w $88(a5)              ;Стартуем копперлист очисткой COPJMP($88).

  ******************СНОВА ВКЛЮЧАЕМ КАНАЛЫ DMA . (только коппер)**************

  move.w #$8280,$96(a5)

  ***************ЖДЕМ НАЖАТИЯ КНОПКИ МЫШИ ПЕРЕД ВЫХОДОМ****************

  pause btst #6,$bfe001      ;CIAPRA=$bfe001, бит 6 этого регистра - нажатие
                              левой кнопки мыши.
  bne.s pause                ;ждем, пока не нажали.

  ***********************ВОССТАНАВЛИВАЕМ СТАРЫЙ КОППЕРЛИСТ******************

  move.l #name,a1            ;имя graphics library.
  cir.l d0
  JMP -552(a6)               ;-552 это смещение OPENLIB.

  move.l d0,a4               ;адрес graphics library.
                              возвращен в d0, сохранен в a4.
  move.l 38(a4),$80(a5)      ;Начальный копперлист перемещаем из адреса базы
                              graphics.library в COP1LC base to
  clr.w $88(a5)              ;стартуем коппер.
  move.w #$8380,$96(a5)      ;и снова включаем DMA
**  примечание  :  наверное  надо  все-таки выключить DMA после нажатия кнопки
мыши, а потом уж снова включать.

  rts

  ******************************* ДАННЫЕ ***********************************

  address dc.l 0

  start:
  dc.w $000f,$fffe,$180,$0000
  dc.w $a00f,$fffe,$180,$fffe
  dc.w $ffff,$fffe
  cop.end:

  size=cop.end-start

  even
  name dc.b "graphics.library",0

                6. ЭКРАНЫ И БИТМАПЫ

                6.1   Цветная графика Амиги
                6.2   Битпланы
                6.3   Создание битпланов
                6.4   Установка окна для экрана
                6.5   Установка размера битплана
                6.6   Установка адреса битплана
                6.7   Пример алгоритма
                6.8   Пример программы
                6.9   Скроллинг

  6.1   Цветная графика Амиги

  Одна  из  основных  составляющих  успешной  игры - это впечатляющая графика.
Большинство  игр  используют  режим экрана 320х200 точек и до 32 цветов, таким
образом, каждый пиксел имеет цвет одного из 32х цветовых регистров.
  Например,  если  пиксел(100,100)  должен  быть зеленым, то один из регистров
должен  содержать  зеленый цвет, и пиксел должен указывать на этот регистр для
придания ему нужного цвета.

  Значение цвета пикселя может быть от 0 до 31, что соответствует 32м цветовым
регистрам.

Цветовые регистры 0-31 :

                00-$180                etc...
                01-$182                29-$1BA
                02-$184                30-$1BC
                03-$186                31-$1BE.
                04-$188
                05-$18A
                06-$18C
                07-$18E
                etc...


Каждый  цвет в 16-ти битном регистре получается смешиванием красного, зеленого
и синего компонентов.

Bits 0-3:  Синий компонент $0-$F(16 уровней)
Bits 4-7:  Зеленый компонент $0-$F(16 уровней)
Bits 8-11: Красный компонент $0-$F(16 уровней)
Bits 12-15:Не используется

Например:
Черный =%xxxx 0000 0000 0000 =$0000
Белый  =%xxxx 1111 1111 1111 =$0fff
Красный=%xxxx 1111 0000 0000 =$0f00


6.2 Битпланы.

  Метод  получения  каждым  пикселем  значения  цветового  регистра основан на
использовании битпланов (битплан - сетка битов). Используя два битплана, можно
отдать каждому пикселу 2 бита, по одному с каждого битплана

  Рассмотрим следующие 2 битплана 4х4:

                0001                 0001
                0010                 0000
                0100                 0000
                1000                 0001
                 #1                   #2

  Верхний левый пиксель имеет значение 0 из первого плана и 0 из второго плана
  Это говорит, что цвет пикселя содержится в регистре 00.
  Верхний правый пиксель = 1,1 и его цвет содержится в регистре %11=3
  Нижний правый пиксель = 0,1 и его регистр %01=1
  Нижний левый = 1,0 , регистр %10=2

  Добавление  третьего  битплана  дает  возможным  8  цветов  (%000  -  %111),
используя 5 битпланов, возможно 32 цвета.

  Каждый  битплан  320х200  занимает  64000  бит,  и  экран с 5 битпланами (32
цветами) будет занимать 40К памяти.

  Вследствие   ограничений   по   памяти,   некоторые  игры  создают  имитацию
полноэкранной игровой области повторением графических сегментов, находящихся в
памяти, а затем скопированных на экран блиттером как необходимо

  Битпланы  состоят  из  набора  слов, так первые 16 пикселей каждого битплана
содержатся в его первом 16-ти битном слове
  Каждый  битплан из 64000 точек использует 64000/16=4000 слов, которые должны
быть  зарезервированы  где-нибудь  в  chip  памяти.  Блок памяти резервируется
вызовом  функции  AllocMem,  с  указанием размера (4000*2*<число битпланов>) в
байтах.
  Указатели  на  начальные  адреса битпланов также должны быть установлены для
того, чтобы контроллер DMA мог найти их в chip памяти.


6.3  Создание битпланов

  Для создания битмапа должны быть выполнены следующие шаги:
Сначала  должно быть установлено окно экрана, затем размеры битплана и выбрано
количество битпланов.

  Для  установки  окна,  через  которое  будет показываться экран, должны быть
определены две координаты.
  Верхняя левая и нижняя правая позиции размещаются в DIsplay Window,
START/STOP:
DIWSTART($08e),DIWSTOP($090).
Эти координаты должны быть установлены как:
            Горизонтально: пиксели (0-320)
            Вертикально: линии растра (0-312).

DIWSTART
Bits 0-7: Содержит горизонтальную стартовую позицию (только 0-255)
Bits 8-15: Содержит вертикальную линию старта (только 0-255)

DIWSTOP
Bits 0-7: Содержит горизонтальную конечную позицию 255 to 320.
              (т.е. запись сюда 10 определит позицию 266)
Bits 8-15: Содержит вертикальную линию 128-312.
              (Если бит 15=1, биты определяют 128-255)
              (Если бит 15=0, биты определяют 256-312)

NB:- Разница между DIWSTART и DIWSTOP должна быть кратной 8!


  6.5   Установка размера битплана

  Контроллер DMA должен знать размеры битпланов для того, чтобы их показывать.
  The DMA must know the size of the bitplanes for it to display them.
По  горизонтали  DMA  должен  начинать изображать дисплей за 17 пикселей перед
позицией  DIWSTART.  Это  достаточное  время  для  считывания первых слов всех
битпланов и комбинирования из них цветных пикселей.
  Эта стартовая позиция записывается в DDFSTART (Display Data Fetch START)
в адрес $092.
Биты  3-7  используются для определения верхних 5 битов 9-ти битового значения
(биты 0-2 - нули)
DDFSTOP  в  $094 определяет конечную позицию и имеет такую же раскладку битов,
как  и  DDFSTART.  Из  значения  DDFSTOP  должны  вычитаться  16  пикселей для
обеспечения работы железа.

DDFSTART ограничен минимумом 24, а DDFSTOP максимумом 216.

  Перед записью значения должны быть поделены на 2.
Пример:

Нормальный экран начинается в 129:
DDFSTART = (129-17)/2 = 56.($38)
DDFSTOP = 56+(320-16)/2 = $d0.


6.6   Установка адреса битплана

  Данные  битпланов  должны  располагаться в chip памяти, и на них должны быть
установлены указатели:

Битплан 1: BPL1PTH($0E0),BPL1PTL($0E2).
Битплан 2: BPL2PTH($0E4),BPL2PTL($0E6).
Битплан 3: BPL3PTH($0E8),BPL3PTL($0EA).
Битплан 4: BPL4PTH($0EC),BPL4PTL($0EE).
Битплан 5: BPL5PTH($0F0),BPL5PTL($0F2).
Битплан 6: BPL6PTH($0F4),BPL6PTL($0F6).

Также должен быть установлен управляющий регистр:
BPLCON0($100) значения бит:
         Бит 2 если =1, устанавливает режим интерлейса
         Бит 10 Если =1, устанавливает Dual playfield
         Бит 11 Если =1, устанавливает HAM
         Биты 12-14 Выбор количества битпланов (0-6).
         Бит 15 Если =1, устанавливает HIRES


6.7   Пример алгоритма

1. Выделить очищенную chip память для всех битпланов.
2. Выделить chip память для коппера.
3. Скопировать или создать копперлист в chip памяти.
4. Выключить DMA.
5. Инициализировать коппер.
6. Назначить цвета регистрам цвета.
7. Установить DIWSTART и т.д.
8. Включить DMA.
9. Изменить память битпланов.
10. При выходе восстановить старый копперлист и очистить память


6.8 Пример программы

Копперлист для этой программы следующий:

                MOVE PLANE.1.H, PLANE.1.H.POINTER($0E0)
                MOVE PLANE.1.L, PLANE.1.L.POINTER($0E2)
                т.д................
                ...(также для остальных планов)...
                WAIT 255,255

В виде слов, это похоже на:

                cop.start               $0e0
                cop.start+1             bit.start(Hi)
                cop.start+2             $0e2
                cop.start+3             bit.start(lo)
                cop.start+4             $0e4
                cop.start+5             bit.start(Hi)+8000
                etc...                  .....
                ......                  .....
                cop.start+21            $ffff
                cop.start+22            $fffe


Программа  создает  копперлист, разбивая адреса на старшие и младшие половинка
командой SWAP и копирует в память копперлиста

*****  ЗАПРАШИВАЕМ CHIP ПАМЯТЬ ДЛЯ БИТПЛАНОВ  *****

       MOVE.L $4, A6
       MOVE.L #(5*8000)*2, 00         ;*5 планов - 8000*2 байт.
       MOVE.L #$10002, D1             ;*$10002 требуем очистки памяти.
       JSR -198(A6)
       MOVE.L D0, BIT.START

*****  ЗАПРАШИВАЕМ CHIP ПАМЯТЬ ДЛЯ КОППЕРЛИСТА *****

       MOVE.L #22*2, 00
       MOVE.L #2, 01
       JSR -198(A6)
       MOVE.L D0, COP.START

*****  КОПИРУЕМ КОППЕРЛИСТ  *****

       MOVE.L COP.START, A0
       MOVE.L BIT.START, D1
       MOVE.W #4, D4
       MOVE.W #$E0, D2
 LOOP: MOVE.W D2, (A0)+
       SWAP D1
       ADD #2, D2
       MOVE.W D2, (A0)+
       SWAP D1
       MOVE.W D1,(A0)+
       ADD.L #8000,D1
       ADD #2, D2
       DBF D4, LOOP

       MOVE.W #$FFFF, (A0)+
       MOVE.W #$FFFE, (A0)

*****  ВЫКЛЮЧАЕМ DMA (КОППЕР, СПРАЙТЫ, БЛИТТЕР И БИТПЛАНЫ)  *****

       LEA $DFF000, A5
       MOVE.W #$03E0, $96(A5)

*****  ИНИЦИАЛИЗИРУЕМ КОППЕР  *****

       MOVE.L COP.START, $80(A5)
       CLR.W $88(A5)

*****  УСТАНАВЛИВАЕМ ЦВЕТА (ТОЛЬКО 2)  *****

       MOVE.W #$0000, $180(A5)
       MOVE.W #$0FFF, $182(A5)

*****  УСТАНАВЛИВАЕМ DIWSTART И Т.Д.  *****

       MOVE.W #$2981, $8E(A5)
       MOVE.W #$29C1, $90(A5)
       MOVE.W #$38, $92(A5)
       MOVE.W #D0, $94(A5)
       MOVE.W #$5000, $100(A5)
       CLR.W $102(A5)
       CLR.W $104(A5)
       CLR.W $108(A5)
       CLR.W $10A(A5)

*****  ВКЛЮЧАЕМ DMA (БИТПЛАНЫ И КОППЕР , БЕЗ БЛИТТЕРА!)  *****

       MOVE #48380, $96(A5)

*****  ИЗМЕНЯЕМ ЭКРАННУЮ ПАМЯТЬ (РИСУЕМ ЛИНИЮ...)  *****

       MOVE.L BIT.START, A1
       ADD #4000, A1
       MOVE #19, D4
LOOP2: MOVE #$FFFF, (A1)+
       DBF D4, LOOP2

*****  ЖДЕМ И ВЫХОДИМ  *****

PAUSE: BTST #6, $BFE001
       BNE.S PAUSE
       MOVE.W #$8060, $96(A5)

       MOVE.L #NAME, A1
       CLR.L D0
       JSR -552(A6)
       MOVE.L D0, A4
       MOVE.L 38(A4), $80(A5)
       CLR.W $88(A5)

       MOVE.L BIT.START, A1
       MOVE.L #(10*8000),D0
       JSR -210(A6)
       RTS

*****  ДАННЫЕ  *****

BIT.START DC.L 0
COP.START DC.L 0
  EVEN
NAME DC.B "GRAPHICS.LIBRARY", 0


6.9 Скроллинг

  Вертикальный  скроллинг  очевидно требует блок памяти, больший, чем видимый,
т.е.  нормальный  битплан  состоит  из  8000  слов,  а  большой  из 16000 дает
двукратное  увеличение  данных  битмапа.  Установка указателей на первое слово
покажет  первые  8000  слов, затем, увеличивая указатели на одну линию до 8000
получим плавный скроллинг одного экрана в другой.
  The bitplane pointers should be changed in the vertical blanking gap, with
the copper. The copperlist is then changed. Change the pointers by getting
the processor to wait for raster line 16,and then alter the copperlist.


                7. СПРАЙТЫ.

                7.1  Введение в понятие спрайта
                7.2  Цвета спрайтов
                7.3  Формат данных спрайтов
                7.4  Объединение спрайтов
                7.5  Активизация DMA спрайтов
                7.6  Столкновения

7.1  Введение в понятие спрайта

  Спрайты   это   специальные   движущиеся   объекты,   позволяющие  расширить
возможности  игр.  Спрайты  хранятся в памяти как маленькие битпланы, и на них
указывают  специальные  регистры.  Амига  может  показывать  до 8 спрайтов, но
существуют методы, позволяющие создать видимость большего количества спрайтов.
Каждый  спрайт  имеет ширину 16 пикселей и неограниченную высоту. В нормальном
режиме спрайты имеют 3 цвета, но 2 спрайта могут быть объединены для получения
15  цветов.  Также  спрайты могут быть объединены вместе для получения большей
ширины.


7.2  Цвета спрайтов

  8  спрайтов  нумеруются  от 0 до 7 и каждый пиксель определяется 2мя битами,
получая  2^2=4  комбинации  на  пиксель.  Это дает 3 цвета и один 'прозрачный'
цвет.
  Эти  цвета  содержатся  в  регистрах  цвета,  и спрайты занимают каждый свои
цветовые регистры:

спрайты 0&1: регистры 17,18,19
спрайты 2&3: регистры 21,22,23
спрайты 4&5: регистры 25,26,27
спрайты 6&7: регистры 29,30,31

  Комбинациям пикселей в спрайте соответствуют следующие регистры:

             00=прозрачный.
             01=рег. 17
             10=рег. 18
             11=рег. 19.

Запись  цветов  в  эти  регистры такая-же, как объяснено в главе 6.1, и адреса
регистров выбираются из списка:ue from:     #00=$180
                                            #01=$182
                                            т.д....
                                            #31=$1BE.

7.3  Формат данных спрайтов

  Данные спрайтов хранятся в chip памяти как список спаренных слов:

                Управляющие данные:2 слова
                данные пикселей для 1й линии:2 слова
                Данные пикселей для 2й линии:2 слова
                т.д....  ...  ...
                Данные пикселей для последней линии:2 слова
                "Маркер конца данных":2 нулевых слова - $0,$0.

  Два  управляющих слова содержат информацию о позиции спрайта на экране и его
типе  -  простой  или комбинированный. Контроллер DMA читает эти слова и затем
изображает линии спрайта до достижения маркера конца - 0,0

СЛОВО 1:
Биты 0-7: Нижние 8 бит горизонтальной стартовой позиции (HSTART).
Биты 8-15:Нижние 8 бит вертикальной стартовой позиции (VSTART).

СЛОВО 2:
Бит 0: 9й бит HSTART
Бит 1: 9й бит VSTOP
Бит 2: 9й бит VSTART
Биты 3-6: Нули.
Бит 7: AT бит- Установлен для комбинированных спрайтов.
Биты 8-15: Нижние 8 бит VSTOP (Конец спрайта по вертикали +1).

Каждая  позиция  спрайта имеет размерность 9 бит, что дает возможные позиции в
диапазоне 0-512 ($0-$200)

7.4  Объединение спрайтов

  Объединение  спрайтов  для  получения 15 цветов делается так: 0&1, 2&3, 4&5,
6&7.  Установка бита AT в управляющем слове нечетного спрайта объединяет его с
парным спрайтом.
  В комбинированных спрайтах каждый пиксел имеет 4 бита, один из каждого слова
данных:
                        Бит 0: 1е слово 0го спрайта
                        Бит 1: 2е слово 0го спрайта
                        Бит 0: 1е слово 1го спрайта
                        Бит 1: 2е слово 1го спрайта


7.5  Активизация DMA спрайтов

  Данные  спрайтов должны быть скопированы в chip память, и на них должны быть
установлены указатели:
            Спрайт 0: $120,$122  Спрайт 1: $124,$126
            Спрайт 2: $128,$12A  Спрайт 3: $12C,$12E
            Спрайт 4: $130,$132  Спрайт 5: $134,$136
            Спрайт 6: $138,$13A  Спрайт 7: $13C,$13E

Первые  из  этих  регистров  содержат  верхние 3 бита 19-ти битного указателя.
Нижние 16 бит - во втором регистре.
  Все указатели должны быть установлены перед включением DMA (бит 5 DMACON) и,
если  некоторые  спрайты  не  нужны,  ихние  указатели должны указывать на два
нулевых слова (0,0)
  Когда DMA читает данные спрайтов, указатель движутся вниз по данным спрайта,
и  Вы  должны  переустанавливать  указатели  в  период vertical blanking gap в
копперлисте:

            1. Подождать начала vertical gap.
            2. Установить указатели спрайтов (также как указатели битпланов.)
            3. Конец копперлиста.

  Этот метод будет устанавливать указатели каждый кадр.
  Однажды показан, спрайт может быть передвинут по экрану изменением позиции в
управляющем  слове.  Это также должно делаться во время vertical blanking gap,
после переустановки указателей

7.6 Столкновения

 Область  экрана,  где  двигаются спрайты называется полем или фоном.
Движущиеся спрайты обычно сталкиваются с другими спрайтами или частями фона, и
зти  столкновения  отображаются  в  Регистре  Столкновений  (Collision Control
register) CLXDAT($00E)

Бит  0:  Столкновения между четными и нечетными полями (сделанными из нечетных
и четных битпланов)
Бит 1: Нечетные битпланы и спрайт 0 (или 1)
Бит 2: Нечетные битпланы и спрайт 2 (или 3)
Биты 3-4: как бит 1, но для остальных пар спрайтов.
Биты 5-8: как биты 1-4, но для четных битпланов.
Бит 9: Столкновения между спрайтами (0 or 1) и (2 or 3).
Бит 10: Столкновения между 0,1 и 4,5
Бит  11-14: Такие-же столкновения между 0/1 и 6/7; 2/3 и 4/5; 2/3 и 6/7; 4/5 и
6/7.
Бит 15: Не используется.

                8. БЛИТТЕР

                8.1  Функции блиттера
                8.2  Окна блиттера
                8.3  Копирование блиттером
                8.4  Минитермы
                8.5  Пример программы

8.1  Функции блиттера

  Блиттер  -  специальное  устройство для копирования блоков из одного места в
другое, его имя расшифровывается как "BLock Image TransferER."
  Это  полезно  для  изображения графики: данные экрана содержатся в памяти, и
блиттер  используется для копирования в память битпланов. Блиттер очень быстр,
он позволяет копировать до 65535 слов за одну операцию

8.2  Окна блиттера

  Блиттер  оперирует  с  областью памяти, которая должна быть определена. (Эти
установки  должны  устанавливаться  последними  изо  всех параметров блиттера,
поскольку они запускают блиттер)
  Размер  окна  блиттера  -  это размер блока для копирования, располагается в
BLTSIZE($058).
Биты 0-5 Содержат ШИРИНУ в словах (0-64) , т.е. 0-1024 пикселя.
Биты 6-15 Содержат высоту в словах (0-1024 слова.)
С  таким  числом  бит  доступны максимальные значения 63 и 1023 , но установка
нуля дает значения 64 и 1024

8.3  Копирование блиттером

  Блиттер  копирует  память  из  3 исходных областей в одну конечную. Исходные
области  (A,B,C) могут быть скомбинированы множеством способов перед отправкой
в конечную область (D)
  Область  приемника блиттер рассматривает как непрерывную, и будет изображать
одну  линию.  Чтобы линии располагались одна под другой, определяется значение
MODULO. Оно содержит число байт между концом одной линии и началом другой.

MODULO = (20 слов - ширина источника в словах )*2
  Начальный адрес источника должен определяться так:
Адрес битплана+ позиция на экране

Это объясняет пример:

  Область  данных  шириной 2 слова и высотой 4 слова (заполненная 1) дает блок
пикселей 32*4.
  Устанавливаем BLTSIZE=(4*64)+2 = 258($102).

Это  будет  изображаться  как  блок 32х4, а не как линия из 128 пикселей, если
задать  значение  MODULO  (20  -  2)  = 18 слов. В регистре MODULO должно быть
указано значение в байтах - 36.

  Начальный  адрес  графики такой-же, как начало битплана, т.е. изображается в
верхнем левом углу.

  Расположение регистров:

Начальный адрес приемника: $054 верхние 3 бита, $056 нижние 16 бит.

Начальный адрес источника A: $050 верхние 3 бита, $052 нижние 16 бит.
(Источники B и C имеют адреса $04C, $04E ; $048, $04A.)

Регистры Modulo     $066 - Приемник.
                    $064 - Источник A, $062 Источник B, $060 Источник C.
Регистры  MODULO  позволяют  копировать  данные  между  областями  с различным
разрешением и размерами.

8.4 Минитермы

  Минитермы  определяют  как  исходные  области  будут объединяться в конечную
область.
  Самый  простой  минитерм  - это минитерм копирования памяти (A=D), он просто
копирует  исходную область в конечную. Действительно минитермы требуют участия
всех  источников,  но это обходится использованием B OR инвертированное B, что
дает множитель 1:
                    A * (B+b) * (C+c) = D.
(b,c означают инверсные B,C. т.е. 0 становится 1, а 1 становится 0.)
Факт, что (B+b) ВСЕГДА=1, следовательно выражение A*1*1=D, или A=D.

  Для  установки  минитермов  используется регистр BLTCON0($040). Нижние 8 бит
определяют  возможные комбинации для следующих исходных областей: A,B,C,a,b,c,
так:
                  бит 0: abc      бит 1: abC       бит 2: aBc
                  бит 3: aBC      бит 4: Abc       бит 5: AbC
                  бит 6: ABc      бит 7: ABC.

Для  A=D  (т.е.  A*(B+b)*(C+c))  раскроем  скобки,  получим  ABC,ABc,AbC,Abc ,
устанавливаем биты 7,6,5,4, суммируем имеющиеся буквы получаем AAAA,BBbb,CCcc.
Последние 2 самоуничтожаются, оставляя A=D

Это очень сложная и утомительная процедура, поэтому приведем несколько готовых
минитерм:

A=D (Пересылка памяти)                 байт=%11110000 = $F0
a=D (Инверсная пересылка памяти)       байт=%00001111 = $0F
A+B=D (Наложение изображения)          байт=%11111100 = $FC
A+B+C=D (Двойное наложение)            байт=%11111110 = $FE
(A*B)=D (Пересечение изображений)      байт=%11000000 = $C0

Минитерм  A+B=D позволяет накладывать изображение A на уже имеющееся на экране
B  и  помещать  назад  в  экран  D. Это позволяет помещать элементы на экран с
задним планом, в отличие от A=D, который вытирает задний план.
   Итак,  после  выбора  операции записываем байт в нижние 8 бит BLTCON0. Биты
8-15 имеют другие функции:
  Биты 8,9,10,11 включают каналы DMA для областей D,C,B,A .
  Биты 12-15 содержат значение СДВИГА (0-15) для области A.
  Эта  операция  сдвига  для данных, проходящих через исходную область А. Если
значение 0, А передается без изменений. Если значение 1, данные будут сдвинуты
на  1  бит  вправо. Бит, выдвигаемый из байта справа будет положен в следующее
слово, что сдвинет все слова источника А вправо.
  Сдвиги на 0-15 пикселей используются потому что данные могут изображаться не
только  на  границах слов, т.е. бит 0,16,32,48 и т.д., а в любом месте экрана,
например  значение  сдвига 6 разместит слово с начальной позиции 6, а не 0 или
16.
Другие  регистры  блиттера,  например BLTCON1($042) содержат подобные значения
сдвига для области B в битах 12-15

8.5  Пример программы

  Следующая простая программа предназначена для копирования блока на экран.

       Закрыть DMA блиттера
       Установить BLTCON0 и BLTCON1
       Установить указатели и значение modulo
       Взять контроль над блиттером вызовом функции 'OwnBlitter'
       Установить окно блиттера (начинает операцию)
       Открыть DMA блиттера

Эта  программа  похожа  на  пример работы с битпланами, поэтому используйте ее
части.
*****  секция установки DIWSTART *************

Затем вставьте:

  MOVE.W #$09F0, $40(A5)                 ;Установка минитерм и каналов A и D
  MOVE.W #$0000, $42(A5)                 ;Сдвига нет.
  MOVE.L #GRAPHIC.START, $50(A5)         ;Указатель на исходное изображение
  MOVE.L BIT.START, $54(A5)              ;Приемник (=Область битпланов)

  MOVE.L #NAME, A1                       ;Открываем graphic.library.
  CLR.L D0
  JSR -552(A6)                           ;
  MOVE.L D0, A6                          ;
  JSR -456(A6)                           ;вызываем "OWNBLITTER"

  MOVE.W #38, $66(A5)
  MOVE.W #1025, $58(A5)                  ;устанавливаем BLTSIZE = 16*1 WORDS

*****  ВКЛЮЧАЕМ DMA  *****

  MOVE.W #$83C0, $96(A5)

*****  ЖДЕМ И ВОССТАНАВЛИВАЕМ  *****

  PAUSE BTST #6, $BFE001                 ;Ждем кнопку мыши
  BNE.S PAUSE

  WAIT BTST #14, $002(A5)                ;Ждем, пока блиттер закончит
  BNE.S WAIT

  JSR -462(A6)                           ;Вызываем "DISOWNBLITTER"
  MOVE.L $4, A6                          ;Восстанавливаем указатель на EXEC

Теперь выкидываем старый **  ВКЛЮЧАЕМ DMA ** , включая старую программу паузы.
Программа продолжается со следующих строк:

  MOVE.L #NAME, A1
  CLR.L D0
  и т.д....

В конец надо добавить следующие данные:

GRAPHIC.START:
  DC.W $FFFF, $FFFF, $FFFF, $FFFF, $FFFF, $FFFF, $FFFF, $FFFF
  DC.W $FFFF, $FFFF, $FFFF, $FFFF, $FFFF, $FFFF, $FFFF, $FFFF

                9. ВЫВОД ЗВУКА

                9.1  Звук Амиги
                9.2  Процедура для вывода звука
                9.3  Звуковые регистры
                9.4  Простой пример синусной звуковой волны
                9.5  Модуляции
                9.6  Музыка

  Амига имеет невероятные возможности генерации стерео звука до 4х каналов,
и  для  того,  чтобы  использовать  эти возможности необходимо понимать как
Амига генерирует звук
  Компьютеры  работают  только  с  числами,  а  не с аналоговыми сигналами,
которые  представляются в цифровом виде с помощью оцифровки. Звуковая волна
разбивается  на  интервалы  и  значения  в этих интервалах сохраняют уровень
звука.
Например, синусоида может быть оцифрованы таким образом:

          30
       20    20
    10          10
   0                0                     0
                     -10             -10
                         -20     -20
                             -30

  Это значит, что Амига может работать с цифровым представлением звука. Она
может эффективно считывать сохраненные значения и проигрывать их, тем самым
воссоздавая звук.
  Все  это  лучше  понимается  на  примере,  но сначала немного технических
подробностей.
  Амига  использует 8-ми битные семплы, дающие интервал уровня звука от 128
до  -127,  в  то  время как высококачественные проигрыватели компакт дисков
используют  16  бит.  Кроме  того, оцифрованный звук расходует много памяти.
Например одна секунда звука с частотой 25KHz занимает 25Кб памяти!

9.2  Процедура для вывода звука

  Алгоритм:
           1. Создайте звуковые данные в chip памяти.
           2. Отключите звуковое DMA.
           3. Установите указатели на звук
           4. Установите регистры длины данных.
           5. Установите громкость и частоту.
           6. Включите DMA.

9.3  Звуковые регистры

  Каждый канал имеет указатель на свои данные:
        Канал 0: $0A0, $0A2, AUD0PTR (старшие 3, младшие 16 bits,
        Канал 1: $0B0, $0B2, AUD1PTR как перед этим)
        Канал 2: $0C0, $0C2, AUD2PTR
        Канал 3: $0D0, $0D2, AUD3PTR

  Также должно быть определено число слов данных:
        $0A4  AUD0LEN   (длина данных в словах.)
        $0B4  AUD1LEN
        $0C4  AUD2LEN
        $0D4  AUD4LEN

  Громкость устанавливается от 0 до 64 для каждого канала:
        $0A8  AUD0VOL
        $0B8  AUD1VOL
        $0C8  AUD2VOL
        $0D8  AUD3VOL

  Частота звука устанавливается как период колебаний звука:
        $0A6  AUD0PER
        $0B6  AUD1PER
        $0C6  AUD2PER
        $OD6  AUD3PER

  Для вычисления значения AUDPER используется формула:

             количество проигрываемых байт семпла в микросекундах
Значение =   ---------------------------------------------------- =
                                      0.279365
             1000000
------------------------------------
число байт в семпле*частота*0.279365

(Округляя к ближайшему целому)

Например, для семпла из 32х байт, проигрываемых с частотой 220Hz значение
1000000/(32*220*0.279366) = 508.

(Ограничение значения регистра AUDPER от 124 до 65535)


9.4  Простой пример синусной звуковой волны

*****  ЗАПРОС CHIP ПАМЯТИ ДЛЯ ЗВУКОВЫХ ДАННЫХ  *****

  MOVE.L $4, A6
  MOVE.L #SIZE, D0
  MOVEQ #2, D1
  JSR -198(A6)
  MOVE.L D0, ADDRESS

*****  КОПИРОВАНИЕ ЗВУКОВЫХ ДАННЫХ  *****

  LEA START, A0
  LEA ADDRESS, A1
  MOVEQ #SIZE-1, D0                        ;счетчик цикла
LOOP MOVE.B (A0),(A1)+
  DBF D0, LOOP

*****  ВЫКЛЮЧАЕМ АУДИО КАНАЛЫ  *****

  LEA $DFF000, A5
  MOVE.W #$000F, $96(A5)

*****  УСТАНАВЛИВАЕМ УКАЗАТЕЛИ  *****

  MOVE.L #ADDRESS, $0A0(A5)

*****  УСТАНАВЛИВАЕМ ДЛИНУ, ГРОМКОСТЬ И ЧАСТОТУ  *****

  MOVE.L #(SIZE/2), $A4(A5)
  MOVE.W #64, $A8(A5)
  MOVE.W #10007, $A6(A5)

*****  ВКЛЮЧАЕМ DMA (КАНАЛ 0)  *****

  MOVE.W #$8201, $96(A5)

WAIT BTST#6, $BFE001
  BNE.S WAIT

*****  ВЫКЛЮЧАЕМ КАНАЛ DMA 0 (ОСТАНАВЛИВАЕМ ЗВУК)  *****

  MOVE.W #1, $96(A5)
  RTS

*****  ДАННЫЕ  *****

  ADDRESS DC.L 0
  START:
  DC.B 0,30,60,90,120,90,60,30,0,-30,-60,-90,-120,-90,-60,-30
  AUD.END:
  SIZE=AUD.END-START

(Эти данные могут быть изменены на ваши семплы)

  Регистры  громкости  и  частоты  могут быть изменены внутри программы или
один из других каналов может быть использован для изменения громкости и/или
частоты.  Например,  звук  из  главы  9.4  имеет  постоянную  громкость, но
возможно    сделать   затухание,   а   затем   запустить  изменение  звука,
определенное   одним   из  других  каналов.  Частота  может  модулироваться
подобным  образом.
  Каждый   канал  может  модулироваться  только  соседним  каналом,  и  для
активизации  модуляции служат биты в регистре ADKCON=Audio and DisK CONtrol
register, $9E запись, $10 чтение.)

Бит 0: Канал 0 модулирует громкость канала 1
Бит 1: Канал 1 модулирует громкость канала 2
Бит 2: Канал 2 модулирует громкость канала 3
Бит 3: Канал 3 не модулирует канал
Бит 4: Канал 0 модулирует частоту канала 1
Бит 5: Канал 1 модулирует частоту канала 2
Бит 6: Канал 2 модулирует частоту канала 3
Бит 7: Канал 3 не модулирует канал
Биты 8-14: Используются контроллером диска
Бит 15: Бит Очистки/Установки как в DMACON


9.6 Музыка

  Последовательность  нот  может  быть легко проиграна на канале изменением
частоты  в регистре AUDPER. Список частот для каждой ноты может содержаться
в  виде  таблицы  слов,  и  процедура  следящая  за  нотами просто изменяет
значение в AUDPER в соответствии с ней.
Например:
             1.  Поместить  указатель  на таблицу частот в адресный регистр
(в chip памяти)
             2. Вычислить период по значению, на которое указывает адресный
регистр.
             3. Положить его в регистр данных.
             4.  Перейти  на  процедуру, которая установит новое значение в
AUDPER и подождет окончания ноты.
             5. Увеличить адресный регистр и повторить.


                10. Мышь, джойстик и прерывания

                10.1  Мышь
                10.2  Кнопки мыши
                10.3  Джойстик
                10.4  Опрос джойстика в играх
                10.5  Прерывания

10.1 Мышь

  Мышь  Амиги - полезное устройство ввода и может превосходно использоваться в
играх.  Внутри мыши находится резиновый шарик, который приводит в движение два
перпендикулярных валика, движущихся по координатам x и y. Эти валики соединены
со счетчиками, которые можно прочитать в:

       Port 1: JOYDAT1($00A)      Port 2: JOYDAT2($00C)
           Bits 0-7: X позиция мыши (0-255)
           Bits 8-15: Y позиция мыши (0-255).

  Каждые  255  значений  счетчика  соответствует  перемещению  мыши  на  4 см.
Указатель мыши является спрайтом и операционная система изменяет его положение
в  vertical  blanking  gap  чтением  счетчиков. Для чтения позиции мыши должны
использоваться регистры спрайтов SPRPOS и SPRCTL, они содержат первые и вторые
контрольные слова каждого спрайта. Обычно в эти регистры пишет контроллер DMA,
но  они  могут быть изменены и процессором (Должны быть определены только биты
HSTART и AT)
           SPRPOS0=$140, SPRCTL0=$142
           SPRPOS1=$148, SPRCTL1=$14A
           SPRPOS2=$150, SPRCTL2=$152
           etc...
           SPRPOS7=$178, SPRCTL7=$17A
Это   позволяет   устанавливать   указатель  мыши  на  экран: его  позиция
отслеживается  программой, которая определяет разницу между текущей позицией и
прочитанными указателями спрайтов. Становится возможным организовывать нажатия
мышкой  на  объекты,  расположенные  на  экране  по координатам и ограничивать
движение указателя мыши границами экрана. Программа опроса мыши в играх должна
также возвращать скорость и направление движения мыши.

10.2  Кнопки мыши

  Левая  кнопка мыши при нажатии устанавливает 6й бит в $BFE001 как показано в
предыдущей  программе,  а  правая  кнопка  может  быть прочитана как 10й бит в
$DFF016.

10.3  Джойстик.

  Для программиста игр более интересен порт джойстика, являющийся тем-же самым
регистром JOYDAT, только использующий биты 0,1,8,9.
               Вправо: бит 1=1, бит 0=0
               Влево:  бит 9=1, бит 8=0
               Вверх:  бит 9=1, бит 8=1
               Вниз:   бит 1=1, бит 0=1.

Пример:
           TEST: BTST #1, $DFF00C
                 BNE DOWN??
                 BTST #9, $DDF00C
                 BNE UP??
                 BRA TEST
           DOWN??:
                 BTST #0, $DFF00C
                 BNE DOWN
                 BRA RIGHT
           UP??:
                 BTST #8, $DFF00C
                 BNE UP
                 BRA LEFT

Кнопка  'огонь'  может  быть  прочитана как бит 6 в $BFE001 и, если джойстик в
порте 2, как бит 7 в нем

10.4  Опрос джойстика в играх

  Главный  цикл  игры  должен  содержать  процедуру  опроса джойстика, которая
изменяет  указатели  на  главный  спрайт  в  vertical  blanking  gap. После ее
завершения  должна  использоваться  вторая процедура, которая обновляет экран,
двигает  врагов, бомбы и т.д. в новые позиции. Проверкой определяются возможные
столкновения  объектов  и если таковых не оказалось, снова выполняется главный
цикл. Эта процедура объяснена более подробно в главе 'Написание Игры'

10.5 Прерывания

  Процессор  видит  все  устройства, присоединенные к нему как участки памяти,
эти  устройства  могут  общаться  с  процессором  посредством  серии проводов,
называемых  ШИНОЙ.  Каждое  устройство  работает  независимо  до тех пор, пока
процессор  не  запросит  отчет  о выполненной работе и запросит передать буфер
устройства  по  шине. Это называется опрос устройства. Однако, если устройство
не может ждать запроса, оно может ПРЕРВАТЬ процессор и запросить обслуживания.
  Для  предотвращения  ситуации,  когда  несколько  устройств  прерывают  один
другого,  каждое  из  них  имеет  уровень приоритета 0-6, который распределяет
очередность.
  Когда  процессор  прерывают,  он  останавливает  выполнение текущей задачи и
переходит  на  процедуру  обработки  прерывания,  которая  указана  в  области
векторов. Мы опустим детальное описание работы с прерываниями, поскольку перед
этим надо понять множество базовых программ


                ЧАСТЬ III:  Написание Игры.

                11. Программирование игры
                    11.1 Начало
                    11.2 Планирование
                    11.3 Утилиты

                12. Структура игры
                    12.1 Идея
                    12.2 Развитие идеи
                    12.3 Анимации и движения
                    12.4 Последние штрихи

                13. Структура программы и маркетинг
                    13.1 Планирование программы
                    13.2 Пример структуры игры
                    13.3 Маркетинг игры

                11. Программирование игры

  11.1 Начало

  Перед  тем,  как  задумываться  о  написании  игры,  Вы должны иметь базовые
понятия о языке Ассемблера.  Другие языки,  такие как BASIC и C сильно
уступают
по скорости машинному коду и скоростным требованиям к играм.
  Вы  должны  понимать,  что  язык  ассемблера не так труден, как кажется. Это
только инструмент для помещения чего-либо в регистры и просмотра результатов в
других регистрах. Понятие регистра самая трудная часть.
  Если  Вы  серьезно настроены написать игру, Вам необходим хороший транслятор
ассемблера,  такой  как Devpac, AsmPro и т.д. (Программы в этой книге написаны
на Devpac)
  Эатем,  Вы  должны понимать, что игры не пишутся одной процедурой. Процедуры
строятся из модулей, которые объединяются в более крупные модули, из которых и
строится   игра.   Например   есть   программа,   обслуживающая  блиттер.  Она
наращивается  до  программы  печати  shape.  Далее,  наращивается для работы с
цветным  экраном.  Добавление  процедуры опроса джойстика позволяет перемещать
человечка  по  экрану.  В  дальнейшем  добавляется  анимация человечка и потом
препятствия и их преодоление.
  Отсюда правило - ВСЕГДА НАЧИНАЙТЕ С МАЛОГО, А ЗАТЕМ РАЗВИВАЙТЕ

Разработайте программы, которые делают определенные вещи, а затем компонуйте.
Пример процедур:
            1. Движения shape по экрану с помощью блиттера
            2. Проигрывания ноты
            3. Чтения нот из памяти и проигрывания
            4. Анимации неподвижного объекта (изменения указателя данных)
            5. Циклического изменения цветов (изменения регистров цвета)
            6. Управляемого джойстиком движения спрайтов
            7. Проверки столкновений спрайтов
            8. Процедуры взрывов
            и т.д.

11.2 Планирование

  Все компьютерные программы должны начинаться с планирования.
Например, в реальной жизни, постройка стены планируется так:

            1. Очистить место
            2. Построить фундамент
            3. Укладывать кирпичи до достижения заданной высоты.

Эти  три шага  дают очертания целой процедуры, но каждый шаг может выть разбит
на меньшие задачи:
Постройка фундамента: вырыть яму, залить бетон, подождать высыхания.
Эти три подзадачи могут быть разделены в свою очередь на более мелкие.

  Этот метод разбиения должен продолжаться до тех пор, пока задачи не сведутся
к  тривиальным. Каждая задача программируется и тестируется, а затем, если она
работает, включается в главную программу. Этот метод сохранит Вам часы отладки
и сделает программирование более простым.
  Можно представить такую последовательность действий при написании программ:
   1. Написать программу    2. Напечатать ее в редакторе
   3. Отассемблировать      4. Запустить
   5. Если не работает, изменить и вернуться на 3.

11.3 Утилиты

  Большое    время   при   написании  игры  тратится  на  написание  различных
полезных  программ  поддержки,  таких, как конвертеры графики из DPaint в свой
формат  для  работы  с  блиттером  и т.д. В разделяемых библиотеках содержится
множество  доступных  программ,  но  серьезные  программисты обычно пишут свои
собственные подпрограммы.

  Перед  написанием  игры  должна  быть написана хорошая утилита для работы со
спрайтом или БОБ (Блиттер объект). Рекомендуются следующие шаги:

1. Написать программу для изображения БОБ на экране.
2.   Написать  программу  чтения  текущих  координат  мыши  и проверки нажатия
кнопок на определенных позициях экрана
3.  Объединить  первые  два  шага  так,  чтобы  нажатие  кнопок  мыши вызывало
движение БОБ по х.
4. Добавить к этому возможность изменения позиции по y
5. Написать программу печати десятичного значения на экране.
6.  Добавить  к этому программу изменения размера БОБ, так, чтобы при указании
других значений переходить на другой БОБ

  Эта  подпрограмма  двигает  БОБ  по  экрану и показывает его координаты. Она
может  развиться  в  большую программу, которая будет показывать крупную сетку
16х16 точек и размещать блоки в ней. Далее, можно ввести возможность изменения
цвета блоков и сделать запись карты блоков на диск в собственном формате.
  Если  озвучить  -  не  большая  проблема  -  сделайте  это.  Итак, вы можете
склониться  к  написанию  коммерческого редактора спрайтов или БОБ-ов.

                12. Структура игры

  12.1 Идея

  Задумка  новой  идеи для игры - задача труднее, чем ее написание. Это потому
что существует множество вариации тем игры: стрелялки, платформы, 3D игры т.д.
  Большинство игр для Амиги не являются таким наркотиком, как некоторые ранние
компьютерные  игры,  но  они продаются за счет своих графических и музыкальных
возможностей и многие программисты уделяют большое внимание сюжету игр.
Действительно хорошая игра должна начинаться с идеи сюжета игры.

  Если  у вас есть идея игры, то Вам может быть достаточно трудно воплотить ее
в  программу,  так  что перед программированием Вы должны мысленно проработать
эту  идею.  Закройте глаза и представьте себе игру, но не надо представлять все
детали  графики,  и когда Вы почувствуете идею, запишите или зарисуйте то, что
мысленно  представили,  а  затем  прервитесь на несколько дней. После этого Вы
будете способны увидеть все дефекты в мысленном представлении игры от начала и
до конца. Если Вы так не делаете, у Вас нет шансов написать хорошую игру.

12.2 Развитие идеи

  Затем, Вы должны начинать думать о деталях, начиная с главных характеристик.
  Если  у  Вас  есть космический корабль, нарисуйте множество их на бумаге, до
тех  пор, пока не увидите то, что Вам нужно. Затем попробуйте нарисовать его в
графическом  редакторе.  Рисунок  на  экране  всегда  отличается от рисунка на
бумаге,  поэтому  Вам  надо  будет  изменить  его  до  тех пор, пока он вам не
понравится. Точно также поступайте и с врагами.
  Дальше  немного  труднее.  Вы  должны  сконвертировать  Ваш  рисунок в БОБ и
написать  программу,  которая  самостоятельно  изобразит  Ваш объект. Если Вам
понравился результат, можно продолжать.

12.3 Анимации и движения

  Программу   надо   изменить   для  управления  джойстиком.  Это  выполняется
установкой  координат  х  и  у  и  изображением  объекта  в  этих координатах.
Координаты меняются джойстиком и объекты перепоказываются в новых координатах.
На  самом  деле,  все  немного  сложнее, потому что старый объект надо стереть
перед выводом нового.

  В  период  vertical  blanking  gap  данные  битпланов, где находятся объекты
должны  быть  изменены и положены назад до того, как луч начнет их изображать.
Более сложно все выглядит, если используется задний план. Решение можно найти,
применив  double-buffering  или  спрайты  -  все  8 объединяются вместе и дают
большой многоцветный объект, а БОБ используется для врагов.

12.4 Последние штрихи

  Задний   план   также   копируется  на  экран  блиттером.  Враги  атакуют  по
преопределенным  законам,  которые  задаются  как DC.L ..... ,где определяются
скорость  движения  и  направление. Условные операторы работают примерно таким
образом: 'если игрок на расстоянии меньше 10 пикселей, бросить на него бомбу'

  Также  должны  быть  добавлены  детекция столкновений и звуковые эффекты.
Игра  теперь может считаться почти законченной. Запомните, что это огромное
количество тяжелой работы и не ожидайте чуда на следующий день.

Начните  с малого и развивайтесь. С приобретением опыта не бойтесь изменять
программы, и Ваши усилия окупятся.


                         13. Структура программы

13.1 Планирование программы

  После  того,  как  Вы  придумали  идею  игры  и  написали несколько своих
процедур, Вы можете начинать думать о соединении их вместе.
  Но  не  просто  так  сесть  и  начать  набирать код, а сначала нарисовать
структуру  программы  на бумаге. Для этого обратитесь к плану в главе 5.5 и
6.7


13.2 Пример структуры игры

  Следующий пример показывает одну из простейших игр: космическую стрелялку
с  одним  врагом.  Эта  структура  только скелет, но он показывает принципы
построения целой игры.

 Инициализация программы.
       Запросите  chip  память  для  коппера,  битпланов, звуковых данных и
спрайтов.
       Создайте  копперлист,  который  устанавливает  указатели  спрайтов и
битпланов
       Скопируйте данные в chip память
       Запустите копперлист и установите цвета
       Установите окно экрана и т.д.
       Установите переменные (например 'bombflag'=false, значит нет бомб)

Главный цикл программы
       Установка регистра жизней = 3
       game: JSR move.alien
             JSR move.base
             JSR bomb
             JSR bullet
             JSR update.screen
             JSR hit.alien?
             JSR hit.base?
             BRA game


Другие подпрограммы

       move.alien: перемещает врага
       Если его позиция не в конце экрана, то передвинуть.
       (Это  не  перемещает  врага,  а  только меняет вектор, т.е. на какое
расстояние от последней позиции он сейчас находится)
       RTS


move.base        ;чтение  положения джойстика. Если в центре, RTS. Изменяем
вектор базы, согласно нажатию, затем RTS

bomb            ;если bombflag=true (т.е. бомба на экране).
                 увеличить ее вектор, RTS.
                 если   bombflag=false,  (т.е.  бомбы  нет),  сгенерировать
случайное  число (используя регистр VPOS) и случайно выбрать, бросать бомбу
или  нет.  Если  решили  не бросать бомбу, то RTS. Если бросать, установить
bombflag=true и разместить бомбу под врагом, затем RTS

bullet           ;если bulletflag=true то увеличить вектор пули вверх, затем RTS
                  Иначе,  прочитать  кнопку джойстика. Если не нажата, RTS.
Иначе, установить bulletflag=true и установить пулю над базой

update.screen     ;Подождать vertical blanking gap и добавить все вектора к
текущим   координатам.  Изменить  данные  спрайтов  и  указателей  на  БОБ,
основываясь на этих новых координатах. RTS.


hit.alien?       ;Если координата пули =координате врага, то JSR explode.
                  Если нет,  проверить,  на экране ли пуля?  Если нет,
удалить пулю и  установить  bulletblag=false,  давая  возможность  еще
одного выстрела. RTS.

hit.base?          ;Если   координаты   бомбы   =   координатам  базы,  JSR
explode_base.  Если  бомба  вылетела  за  экран,  убрать  ее  и  установить
bombflag=false.

explode           ;Изменить  указатели  на данные врага на указатели 'взрыв
врага'.  Затем  удалить  врага  и  добавить очки. Установить нового врага в
другом месте.

explode.base      ;Тоже, что и взрыв врага, но забрать одну жизнь. Если это
была последняя жизнь, закончить игру.

  Вот и все. Не ожидайте, что Вы напишете  игру  за  одну  ночь,  даже  лучшим
программистам для этого нужны годы.
  Если Вы чувствуете в себе силы, все нормально, но некоторые даже не знают, с
чего начать.

                        Эта книга показала Вам как.
                           Теперь дело за Вами!
