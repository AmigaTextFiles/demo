                            <B>Aga Chipset</B>
                               Part 2
                          (c) Zetter 2001
                contact 2:5025/2000.110, zetter_@euro.ru

Здравствуйте, уважаемые читатели! Я рад снова  приветствовать  вас  в  гостях  у
журнала  Power Amiga и вижу, что вы не забыли заглянуть и в рубрику, посвященную
программированию!

В этом номере  вас  ждет  окончание  статьи,  посвященной  программированию  AGA
чипсета, начатую в 3 номере нашего журнала.

Надо сказать, что, поскольку оригинал текста достаточно старый,  то  в  процессе
перевода были обнаружены достаточно своеобразные советы, которые как мне кажется
немного устарели, особенно, если учесть, что на  дворе  уже  2001  год.  Главным
образом  это  касается последней части статьи, посвященной ошибкам программистов
старых дем. Особенно меня умиляют неоднократные заверения автора о том,  что  не
беспокойтесь,  мол,  кэши  при  старте  отключены,  и  если  вы загрузите демо с
дискетки, все будет окей :-))) Я сам уже и забыл, что такое дискетки...  :-)))))
Ну это я так, отвлекся.

Теперь немножко анонсов.  В  5  номере  журнала  я  продолжу  этот  цикл  статей
описанием  регистров  чипсета  и  CIA,  и,  надеюсь,  благополучно  завершу этот
многострадальный труд.

Кстати, вскорости после выхода этого номера, на Аминете можно будет найти версии
всех  статей,  опубликованных  ранее,  интергированные  в  одно  целое в формате
AmigaGuide. Следите за новыми uploadами!  Ну  вот,  кажется  мне  больше  нечего
сказать, желаю вам приятного чтения, господа программисты!

СОДЕРЖАНИЕ
==========
68020
 getVBR
 кэши (пример выключения)
 отличия системы команд 68020+
 68040 copyback
 NO 68040 MMU
 очистка памяти процессором
как писать демы/игры,  работающие  на  всех  машинах  (примеры  распространенных
ошибок)
 01 Старые упаковщики.
 02 Нет waitblit
 03 Неправильная установка копперлиста
 04 Самомодифицирующийся код
 05 Моргание клавишей capslock
 06 Ошибка в проигрывателе музыки
 07 Неправильная адресация
 08 Проблемы с 68040
 09 Неправильные загрузчики
 10 Синхронизация
 11 Команда clr на $DFFxxx
 12 Выравнивание кода по границам 32бит
 13 Использование зарезервированных бит
 14 Вызов disable

== Запомните, что машины с AGA чипсетом имеют процессор 68020 или старше ==

Тогда почему это мало используется? Процессор будет работать  быстрее,  особенно
если  вы имеете fast RAM и код программы располагается там. Быстродействие будет
в 2 раза больше или даже в 3 или 5 раз больше на A4000, если вы загружаете код в
fastram,  а  не  в chipram. И не забывайте, что вы имеете 32-х битный процессор,
так что быстродействие будет больше если вы выравниваете  подпрограммы  по  32-м
битам (1 длинное слово), используя команду CNOP 0,4 перед всеми подпрограммами и
данными.

ПРЕДУПРЕЖДЕНИЕ:

Начиная с 68010 значение регистра VBR может быть изменено, чтобы  вместо  $0  он
указывал в fast RAM так, что все векторы прерываний (подобно $6c) и trap векторы
(подобно $80) размещщаются в fast RAM по адресам VBR+$6c  и  VBR+$80...  Это  не
проблема если вы это знаете! Можно установить VBR обратно в $0, чтобы обеспечить
совместимость со старыми программами, но ТЕПЕРЬ  мы  должны  писать  НОВЫЙ  софт
используя  небольшое  увеличение  быстродействия  VBR  в fast RAM... Так что вам
необходимо ЗНАТЬ как оперировать с VBR и делать смещения от VBRBASE:

GETVBR:
    MOVE.L  4.W,A6
    SUBA.L  A1,A1
    btst.b  #0,$129(a6)  ; Тест на процессор от 68010 и старше
    beq.S   INTDONE      ; это 68000!!
    LEA SUPERCODE(PC),A5 ; это 68010, или 20, или 30, или 40, или 60 или ?
    JSR -$1E(A6)       ; выполняем подпрограмму 'supercode' в режиме супервизора
    BRA.S   INTDONE
    CNOP    0,4          ; выравниваем по границе 32 бит (длинное слово)

************КОД ИСКЛЮЧЕНИЯ В РЕЖИМЕ СУПЕРВИЗОРА 010 И СТАРШЕ ****************
SUPERCODE:
    dc.l    $4e7a9801    ; Movec Vbr,A1 (команда 68010 и старше)
                    ; дана в шестнадцатиричном виде, поскольку не все ассемблеры
                    ; могут ассемблировать команды 68010
    RTE             ; возврат из исключения
***************************************************************************

    CNOP    0,4          ; выравниваем по границе 32 бит (длинное слово)
INTDONE:
    LEA $DFF000,A5  ;
    LEA VBRBASE(PC),A0
    move.l  a1,(A0)      ; сохраняем VBRBASE по метке 'VBRBASE'
    LEA OLDINT(PC),A2
    move.l  $6c(a1),(A2) ; записываем $6c(a1) (старый адрес)
    ....

При старте системы VBR устанавливается в $0, и trakmo или демо, загружающиеся  с
диска  будет работать с $6c.w и $80.w, но SETPATCH или другие утилиты перемещают
VBR в fast RAM.

Если вы программируете 3d или фрактальные подпрограммы и вы  располагаете  их  в
32bit  RAM,  быстродействие  будет  зависеть  от  процессора,  в отличие от того
случая, когда вы размещаете весь код в chip RAM  или  по  фиксированному  адресу
(через  ORG&LOAD). В chip быстродействие будет одно и то же на всех процессорах.
Этот значит, что подпрограммы которым не нужно быстродействие A4000 можно (но не
нужно)  размещать  в  chip  (section  NAME,CODE_C), а подпрограммы которым нужна
скорось большая, чем у голой 1200 будут размещаться в 32bit  fastram  (если  она
существует,  section name,CODE). Я думаю, лучший способ программирования состoит
в  том,  чтобы  делать  перемещаемый  код,  с  ханками  в  fast,  и  упакованный
Powerpacker-ом.  Если вы кодите trackmo, попробуйте обнаружить где располагается
fast RAM, и перемещайте код туда. Например, fast RAM на A4000  располагается  по
адресам $07c00000 - $07ffffff.

Как использовать КЭШ-ПАМЯТЬ:

На 68020+ имеется 256-ти байтный Кэш команд, который ускоряет операции, так  как
команды  в  цикле  читаются  из  КЭША  вместо  ОЗУ.  Единственая  проблема - это
использование самомодифицирующегося кода. В некоторых случаях изменение не будет
выполнено... Например:

    MOVE.W #0,d6    ; Если кэш не очищен перед этим, то команда будет  сохранена
CHANGEX: EQU *-2    ; в КЭШЕ, а ОЗУ останется без измений  и  в  итоге  возможен
                    ; аварийный отказ!
                    ; (Icache на 68020/30 - 256 байт, на 040 - 4096 b.)
    ADDI.W #$50,CHANGEX; изменение команды
                    ; Здесь вы должны очистить КЭШ! (flush)

Очистите кэш прежде, чем выполнить измененную команду,  или  изменяемая  команда
будет читаться из кэша, а там осталась та же самая команда MOVE.W 0, D6.

Для лучшей производительности критично, чтобы  главные  циклы  кода  выполнялись
полностью в Icache (256 байт). Цикл длиной 258 байт будет выполняться медленнее,
чем длиной 254 байт. Цикл, длиной 258 байт будет вызывать неудачное обращение  в
кэш  (слово  в начале или в конце цикла). Цикл, длиной 512 байт будет заставлять
систему переписывать весь кэш. Поэтому цикл из 254 байтов будет быстрее  чем  из
258 байтов, но только незначительно.

На 68030 и 68040 имеется также DataCache, в который загружаются ДАННЫЕ, и  после
этого  они  читаются  из  кэша,  а не из ОЗУ. Если вы изменяете данные, то будет
случаться то же самое, что и с кэшем команд - изменяемые данные  могут  читаться
из  кэша.  (256  байт  на  68030, 4096 на 68040 ) - НА AMIGA КЭШ ДАННЫХ РАБОТАЕТ
ТОЛЬКО В FAST RAM.

Пример:

SCROLLVALUE:
    DC.W        ; Будет загружаться из Кэша Данных, но только если это fast RAM!
    ADDQ.W 1, SCROLLVALUE ;изменение данных
; теперь надо очистить DCACHE если SCROLLVALUE находится в fastram или повторное
; чтение этого значения будет тем-же самым, если оно в кэше!

Запомните: чтобы ускорить ваш код на 030+ используйте таблицы длиной 254 байта и
помещайте их в fast RAM!

Не отключайте IntructionCache или DataCache! Если  это  возможно,  наслаждайтесь
этим!  И  если вы все-же хотите это сделать, не думайте, что биты CACR - на всех
процессорах те же самые! Многие демо, подобно DESERT DREAMS/KEFRENS не  работают
на   040,   потому   что  используется  подпрограмма  отключения  КЭША,  которая
устанавливает  биты  CACR  для  68020/30...  Перед  изменением  CACR  вы  ДОЛЖНЫ
распознать  используемый  процессор, и только после этого включать или выключать
кэш.

NOCACHE2030:            ; если обнаружен 020 или 030

    BSR.W   CACHECLR    ; перед включением/веключением надо очистмть кэш!
    dc.l    $4e7a0002   ; movec  cacr,d0 (команда 68020+)
    BCLR.L  #8,d0       ; Data Cache 68030 (BCLR = выключен)
    BCLR.L  #0,d0       ; Instruction Cache 68020-30 (BCLR = выключен)
    dc.l    $4e7b0002   ; movec  d0,CACR (команда 68020+)
    rte

NOCACHE40:

    BSR.W   CACHECLR    ; перед включением/веключением надо очистмть кэш!
    dc.l    $4e7a0002   ; movec  cacr,d0 (команда 68020+)
    BCLR.L  #31,d0      ; Data Cache 68040 (BCLR = веключен)
    BCLR.L  #15,d0      ; Instruction Cache 68040 (BCLR = выключен)
    dc.l    $4e7b0002   ; movec  d0,CACR (команда 68020+)
    rte

ОБРАТИТЕ ВНИМАНИЕ: ( из C= autodocs V40 )

Для всех существующих моделей АМИГИ, chip память может  быть  кэширована  только
кэшем  команд,  кэш  данных  в  ней заблокирован. Это сделано для предотвращения
конфликтов с блиттером  и  другими  спец.  чипами.  Регистры  чипсета  также  не
кэшируются.

СОВЕТЫ: ( Из HOWTOCODE 7 )

Запись в память имеет состояния ожидания. Однако,  в  то  время  как  происходит
ожидание записи, процессор может выполнять другие команды:

        Move.l d0, (a0) +       ; Сохраним x координату
        Move.l d1, (a0) +       ; Сохраним y координату
        Add.l d2, d0            ; X + =deltax
        Add.l d3, d1            ; Y + =deltay

; Будет медленнее чем:

        Move.l d0, (a0) +       ; Сохраним x координату
        Add.l d2, d0            ; X + =deltax
        Move.l d1, (a0) +       ; Сохраним y координату
        Add.l d3, d1            ; Y + =deltay

68020 добавляет ряд расширений к архитектуре  68000,  включающие  новые  способы
адресации  и  команды.  Некоторые  из  их  существенно ускоряют работу программ,
другие только иногда помогают:

(Для ассемблирования команд 68020+ используйте TFA ASMONE или DEVPAC 3.x )

* Масштабируемая Индексация. Метод адресации 68000 (disp,An,Dn ) на 68020  может
иметь коэффициент масштабирования 2,4, или 8 у регистра данных. Пример:

        68000                   68020
        -----                   -----
        Add.w d0,d0            Move.w (0,a1,d0.w*2),d1
        move.w (0,a1,d0.w),d1

* 16 битовые смещения в  режимах  An+Rn.  68000  обеспечивал  только  8  битовые
смещения.  При  использовании  суммы  адресного  регистра и другого регистра как
адреса памяти 68020 поддерживает  16  битовое  смещение.  Эта  команда  работает
медленнее  на один дополнительный такт, когда она не в кэше, но точно с такой-же
скоростью, если команда находится в  кэше.  32х  битовые  смещения  также  могут
использоваться, но они расходуют по 4 дополнительных такта.

* Регистры Данных могут использоваться как адресные регистры. (D0) - на 3  такта
медленнее  чем  (a0). Хотя перемещение регистра данных в регистр адреса занимает
всего 2 такта, эта команда может помочь в ситуации нехватки  свободных  адресных
регистров.

* Косвенная адресация памяти. Эти команды могут помочь  в  некоторых  ситуациях,
когда  нет  никаких  свободных  регистров  для  размещения  указателя.  В других
обстоятельствах эти команды проигрывают по всем параметрам.

Новые команды:

* Команды умножения и деления с расширенной  точностью.  68020  может  выполнять
умножение  32x32->32, 32x32->64 и деление 32/32 и 64/32. Они значительно быстрее
чем команды с мульти-точностью, требующиеся на 68000.

* EXTB. Знаковое расширение байта до длинного слова. Быстрее  чем  эквивалентная
последовательность EXT.W и EXT.L на 68000.

* Непосредственное сравнение и TST на 68020 работают в режиме относительной (PC)
адресации.

* Команды работы с битовыми полями. BFINS вставляет  битовое  поле,  и  работает
быстрее  чем  2  MOVE  плюс AND и OR. Эта команда может приятно использоваться в
подпрограммах заливки или печаталках текстов. BFEXTU/BFEXTS  может  извлекать  и
опционально  расширять  знак  битового поля в произвольных границах. BFFFO может
находить самый старший установленный бит в битовом поле. BFSET, BFCHG,  и  BFCLR
могут устанавливать, дополнять, или очищать до 32 бит в произвольных границах.

*  На  020,  все  команды  сдвига  выполняются  одинаковое  количество  времени,
независимо от того, на сколько бит происходит сдвиг. Обратите Внимание что ASL и
ASR медленнее, чем LSL и LSR.

* 020 имеет команды PACK и UNPACK, которые могут быть полезны.

=68040 CopyBack=

68040 отличается тем, что он имеет режим copyback. В этом режиме (который  БУДЕТ
ИСПОЛЬЗОВАТЬСЯ людьми, потому что он сильно увеличивает быстродействие) запись в
память кэшируется и не гарантируются немедленная запись в ОЗУ. Таким  образом  4
последовательных  байтовых  записи в память будут требовать только один доступ в
память для записи длинного слова. Теперь вы могли слышать что 68040 контролирует
шину. Странно, но это не так! Процессор не контролирует внутренние шины кэша!

Таким образом если  вы  записываете  некоторый  код  в  память  и  пробуете  его
выполнить,  возможно  этот код будет еще в кэше данных. Кэш команд об этом знать
не будет и может случиться такая вещь, когда процессор будет пытаться  выполнить
команды,  которые  еще  не  были  записаны в память из кэша данных. Эта проблема
усиливается  абсолютно  огромным  размером  кэшей.  Так  что  программы  которые
перемещают  код,  подобно  алгоритмам  взрыва,  должны делать очистку кэша перед
выполнением.

На a4000 copyback и  MMU  выключены  при  начальной  загрузке  (после  включения
питания)  так  что  нет никаких проблем при запуске trackmo или демо с диска, но
начиная с WB 3.0 mmu и CopyBack  активируются  (используя  68040.library)  и  вы
должны  учитывать  это.  Лучший  способ - обнаруживать, что мы запущены на 040 и
отключать MMU этой подпрограммой:

    MOVE.L  4.W,A6
    btst.b  #3,$129(a6) ; Проверка на 68040+
    bne.S   P68040
    rts

P68040:
    move.l  4.w,a6
    lea NO040MMU(PC),a5
    jsr -$1e(a6)        ; выполнение NO040MMU как исключения
    rts

NO040MMU:               ; (Thanx to Rhino/team HOI and Remote Control)
    lea $FFC000,a0
    dc.l    $4e7b8004   ; movec a0,ITT0
    dc.l    $4e7b8005   ; movec a0,ITT1
    dc.l    $4e7b8007   ; movec a0,DTT1
    lea $c040,a0
    dc.l    $4e7b8006   ; movec a0,DTT0
    lea $30000,a0
    dc.l    $4e7b8806   ; movec a0,URP
    dc.l    $4e7b8807   ; movec a0,SRP ; Supervisor Root pointer reg.
    suba.l  a0,a0
    dc.l    $4e7b8003   ; movec a0,TC  ; translation code register
    rte

ПРИМЕЧАНИЕ:

Многие подпрограммы отключения MMU имеют только MOVEC A0,TC  без  других  команд
прежде...  Это  работает  на  030  mmu, но причиняют ГРАНДИОЗНЫЙ СБРОС + GURU на
A4000/040. Не удаляйте 68030 MMU,  потому  что  некоторые  A3000's,  загружающие
kickstart в ОЗУ рушатся при попытках отключать кэш.

Очистка блиттером
-----------------

Если вы используете блиттер для очистки больших кусков памяти, вы можете  сильно
увеличить  быстродействие  на  более  старших  процессорах  (68020+) заменив его
циклом, вмещающимся в кэш, который очищает командой movem.l:

        moveq  #0,d0
        moveq  #0,d1
        moveq  #0,d2
        moveq  #0,d3
        moveq  #0,d4
        moveq  #0,d5
        moveq  #0,d6
        sub.l  a0,a0
        sub.l  a1,a1
        sub.l  a2,a2
        sub.l  a3,a3
        sub.l  a4,a4
        sub.l  a5,a5

        lea    Endofбитplane,a6
        move.w #(bytes in plane/156)-1,d7
.Clear
        movem.l d0-d6/a0-a5,-(a6)
        movem.l d0-d6/a0-a5,-(a6)
        movem.l d0-d6/a0-a5,-(a6)
        dbf d7,.Clear

; Еще пара movems может быть необходима чтобы очистить последние байты экрана...

Этот цикл был (на нашем 1200) почти в три раз быстрее чем блиттер.


*****************************************************************************
*       ТЕПЕРЬ ЧИТАЙТЕ КАК КОДИТЬ ДЕМО/ИГРЫ, РАБОТАЮЩИЕ НА ВСЕХ МАШИНАХ!    *
*****************************************************************************

Теперь, после объяснения НОВЫХ особенностей AGA, я должен также  объяснить,  как
писать совместимый код. Наличие мощной АМИГИ также означает, что надо исправлять
много старого софта. Я исправлял сам много старых и  НОВЫХ  программ!  Это  были
демо/игры,  и  я  делал так, чтобы они работали на машинах лучше чем A500... Это
мне надоело! И теперь я думаю, что лучше кодить демо так, чтобы они не нуждались
в исправлениях.

Здесь я сделал отчет по ошибкам, которые вызывают  несовместимость даже  если
кэши отключены, VBR равен 0, и AGA сбрасывается добавлением:

    Dc.w    $1fc, 0
    Dc.w    $106,$c00
    Dc.w    $10c,$11

в копперлист...

ОТЧЕТ:

1) Демо, упакованные старым CRUNCHER-ом по абсолютным адресам... Наиболее старые
программы  распаковки  вызывают  аварийный  отказ  перед  выполнением  демо... Я
распаковывал их на A500 и повторно упаковал их  STONECRUNCH  4  если  демо  было
написано  по  абсолютным  адресам или powerpacker, если был написан перемещаемый
код (это лучше)

2) НЕ ДОЖИДАЮТСЯ ОКОНЧАНИЯ РАБОТЫ БЛИТТЕРА ПЕРЕД ПОВТОРНЫМ ЗАПУСКОМ...  Особенно
часто  встречается  в  коде  до 1990. Эти кодеры сказали себе: это работает, так
зачем добавлять подпрограмму waitblit?? Но на более быстрых процессорах возможен
АВАРИЙНЫЙ ОТКАЗ!

    LEA $dff000,a5
WaitBlit0:
    BTST.B #6,2(a5)
WaitBlit1:
    BTST.B #6,2(a5)     ; 2-й раз из-за bugs в очень старых чипах
    BNE.S WaitBlit1

3) Неправильное обращение к адресам, работающее только на 1.x kickstarts

    move.l  4.w,a6      ; execbase
    move.l  (a6),a6     ; ???
    move.l  (a6),a6     ; ХАХАХА! GFXBASE???
    move.l  $26(a6),OLDCOP  ; ХАХАХА! Сохраняем старый копперлист???
    move.l  #MYCOP,$32(a6)  ; Двойное ХАХАХА! Указатель на копперлист???

Этот большой фрагмент неправильного кода был в  intro  от  ORACLE,  и  в  других
старых  демо..  Не  забывайте ОТКРЫВАТЬ gfxbase для сохранения старого coplist и
устанавливать указатель на новый coplist командой MOVE.L  #MYCOP,$dff080...  Это
лучше.

4) Самомодифицирующийся код будет вызывать  проблемы  если  включен  кэш  команд
Некоторые примеры:

    Divu.w #0,d0; значение будет  изменяться перед выполнением, но
MYLABEL:        ; с включенным ICACHE команда вероятно будет читаться из
    EQU * -2;   ; неизмененного КЭША.. И ДЕЛЕНИЕ на 0 остановит забаву :-)

Или:

    JMP 0  ; адрес будет размещен здесь.. Но если кэш включен, мы будем иметь
MYLABEL:   ; ГРАНДИОЗНЫЙ ПРЫЖОК НА 0!! с устрашающим GURU
    EQU *-6; (или EQU *-5, EQU *-4...)

Но есть выход!! Вы должны ОЧИЩАТЬ кэш перед выполнением изменяемых  команд,  или
удалением  с/м  кода.  Приемы  которые  не  полезны... Но они не выключают кэши,
наслаждайтесь этим! Подпрограмма ОЧИСТКИ КЭША - здесь:

CACHECLR:
    MOVEM.L D0/A5-A6,-(SP)
    MOVE.L  4.W,A6        ; EXECBASE в A6
    BTST.B  #1,$129(A6)   ; Тест на 68020+
    BEQ.S   NOCACHE
    BSR.S   DOCLEAR
NOCACHE:
    MOVEM.L (SP)+,D0/A5-A6
    RTS

    CNOP    0,4

DOCLEAR:
    MOVE.L  4.W,A6        ; EXECBASE в A6
    LEA CCLEAR(PC),A5
    JSR -$1E(A6)          ; Выполняем CCLEAR в режиме супервизора
    RTS

    CNOP    0,4

CCLEAR:
    BTST.B  #3,$129(A6)   ; Тест на 68040
    BNE.S   CLR040
                          ; Очищаем 68020/30 ICACHE и 030 DCACHE
    ORI.W   #$700,SR      ; Вырубаем прерывания
    dc.l    $4E7A0002     ; MOVEC  CACR,D0
    BSET.L  #3,D0         ; Очищаем INSTRUCTION CACHE 020/030
    BSET.L  #11,D0        ; Очищаем DATA CACHE 030
    dc.l    $4E7B0002     ; MOVEC  D0,CACR
    RTE

    CNOP    0,4

CLR040:                   ; Очищаем 68040 ICACHE и DCACHE
    dc.W    $F4F8         ; CPUSHA BC (или  DC.W $F478 CPUSHA DC для DCAC)
    RTE

Эта подпрограмма работает также на  kickstart  1.x  и  должна  вызываться  после
загрузки  кода  с  диска или после запрещенной модификации памяти, которая могла
вызвать недопустимые или устаревшие данные в кэше.

На 68030/68040 процессорах имеется КЭШ ДАННЫХ, который делает то  же  самое,  но
только для ДАННЫХ, находящихся в fast RAM.

5)  ПОДПРОГРАММЫ,  МИГАЮЩИЕ  CAPSLOCK-ом:  некоторые  демо  имеют  подпрограмму,
мигающую  клавишой  CapsLock на клавиатуре, подобно демо ODISSEY Alcatraz... Эта
подпрограмма отлично работает на a500, a1000, a2000, a3000,  a4000  но  вызывает
СБРОС  на a1200!! так НЕ ИСПОЛЬЗУЙТЕ ЭТОТ ВИД ПОДПРОГРАММ или ваше демо не будет
работать на A1200

CAPSLOCK:
    LEA $BFE000,A2
    MOVEQ   #6,D1        ; бит 6 $bfee01 бит ввода вывода $bfec01
    CLR.B   $801(A2)     ; TODLO - бит 7-0 таймер на 50-60hz
                         ; сброс таймера
    CLR.B   $C01(A2)     ; Очистка SDR (синхронный последов. сдвиг. регистр
                         ; подключенный к клавиатуре) - 8 бит -
DOFLASH:
    BSET    D1,$E01(A2)  ; Вывод
    BCLR    D1,$E01(A2)  ; Ввод
    CMPI.B  #50,$801(A2) ; Ждем 50 vblank (таймер CIA)
    BGE.S   DONE
    BSET    D1,$E01(A2)  ; Вывод
    BCLR    D1,$E01(A2)  ; ввод
    MOVE.W  $DFF01E,D0   ; Intreqr в d0
    ANDI.W  #%00000010,D0; Проверка I/O портов
    BEQ.S   DOFLASH
DONE:                    ; Теперь наша A1200 полностью разрушена!

6) Ошибка в проигрывателе музыки:

Я нашел ошибку в intro PARADOX и других demo: проблема в проигрывателе музыки:

MT_MUSIC:
    MOVEM.L D0-D4/D7/A0-A6,-(SP)
    LEA 0,A4     ; Почему использется $0??? Изменение первых байт памяти будет
    ....         ; вызывать сбой (на kick 3.0 точно)

Работайте с буфером вместо $0:

MT_MUSIC:
    MOVEM.L D0-D4/D7/A0-A6,-(SP)
    LEA LABEL,A4 ; и в конце подпрограммы разместите буфер!

LABEL:
    dcb.b   50,0

7) Ошибка АДРЕСА:

Использование абсолютного адреса $C00000... Некоторые старые  программы  требуют
1МБ  памяти, причем старшие 512КБ по адресу $C00000, где размещается расширенная
память A500. Но в машинах с 1Мб chip (a500+,a600...) эта память располагается по
адресам $80000 до $100000 ... и $C00000 не существует! Если вы хотите разместить
код в fast RAM используйте опцию ассемблера "SECTION name,CODE"

   Режимы адресации:

Всегда записывайте 24-х битные адреса (типа $123456 ) с нулями в  старшем  байте
($00123456). Не используйте старший байт для данных, для хранения вашего IQ, для
скроллирующихся сообщений или для чего-нибудь еще. 32-х битные CPU,  такие,  как
020 используют также и старший байт адреса. Пример:

  Move.b #$ff,$00000004 ; будет изменять 8 бит указателя ExecBase!

Аналогично,  на  не  ECS  машинах  нижняя  часть  512КБ   памяти   четыре   раза
дублировалась по шине адреса, например:

    Move.l #$12345678,$0

    move.l  $80000,d0   ; d0 = $12345678
    move.l  $100000,d1  ; d1 = $12345678
    move.l  $180000,d2  ; d2 = $12345678

Это не работает над ECS и выше !!!! Вы будете получать бессмысленные результаты!

8) Проблемы 68040: Я нашел, что демо/игры которые не работает на 040 и  работают
на 020/030 имеют единственый баг в подпрограмме ОТКЛЮЧЕНИЯ КЭША: кодеры добавили
команду, чтобы отключать кэши, которая работает на 020/030 и  рушит  систему  на
040... Так что же лучше - программа, которая работает на 040 при выключении кэша
при загрузке или совершенно не работающая программа из-за неправильной программы
выключения этого кэша???

9)  Плохие   загрузчики:   некоторый   demos/trackmo   используют   направильную
подпрограмму  задержки  для  загрузчика,  основанную  на  цикле  DBRA,  если она
работает в кэше - наблюдается  ускорение  работы,  что  вызывает  ошибки...  Для
ожидания  используйте  таймеры  CIA!!  и  не забывать очищать КЭШ после загрузки
данных!

10) Синхронизация: не используйте циклы DBRA или большое  количество  NOP's  для
синхронизации  вашего  кода, используйте vblank или CIA. И помните, что на более
быстрых процессорах вы должны  ждать  луча  больше  времени  для  предотвращения
моргания (если подпрограмма модифицирует битпланы когда луч рисует их!) Пример:

WAIT1:
    MOVE.L  $dff004,D0     ; VPOSR
    LSR.L   #8,D0
    ANDI.W  #%111111111,D0 ; Выбрали только биты VPOS
    CMPI.W  #255,D0        ; ждем строки 255
    BNE.S   WAIT1

    JSR DOTFLAG            ; выполнили подпрограмму рисования

WAIT1:
    MOVE.L  $dff004,D0     ; VPOSR
    LSR.L   #8,D0
    ANDI.W  #%111111111,D0 ; Выбрали только биты VPOS
    CMPI.W  #300,D0        ; ждем строку 300
    BNE.S   WAIT1

    JSR VECTOR1     ;

С  таким  подходом  к  ожиданию  вы  будете  уверены,  что  подпрограммы   будут
выполняться в то же самое время по лучу, как и на машинах с 68000. Я думаю - для
синхронизации лучше использовать VPOSR, потому что при использовании  прерывания
$6c вы должны сбрасывать VBR и я отметил, что некоторые демо, которые используют
прерывания работают намного хуже.

11) Не используйте команду CLR применительно к регистрам $dffXXX, потому что  со
стробовыми  регистрами  (подобно  $dff088)  вы  будете  выдавать  импульс строба
дважды, и я отмечал проблемы при использовании clr с другими регистрами, подобно
$dff064..

    MOVE.W #0,$DFF088; нет больше CLR.W $dff088!
    MOVE.W #0,$DFF064; нет больше CLR.W $dff064

12) Не забывайте выравнивать код и данные по 32-м битам, добавляя  команду  CNOP
0,4  перед  метками.  Это  будет  ускорять  код,  если он будет размещен в 32bit
fast RAM. Но не забывайте также выравнивать данные по  словам,  даже,  если  они
находятся в chip памяти, на 020+ это тоже ускоряет код!

13)  Не  используйте  зарезервированные  биты  в  $dffXXX!  Используйте   только
известные биты, иначе в будущем ваш код будет вызывать странные эффекты на более
новых чипах!

14) Не забудьте вызывать  функцию  disable();  JSR  -$78(a6);  перед  изменением
состояния  INTENA  в  начале  вашего  кода! Я исправил большое количество intros
только лишь добавлением этогй команды  и  enable();  JSR  -$7e  (a6);  в  конце.
Вероятно на kick 3.x имеются системные подпрограммы прерываний, которые вызывают
проблемы если они не заблокированы.




