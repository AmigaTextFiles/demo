                   <B>Оптимизация для процессров серии MC680x0.</B>

 Данная  статья  не претендует на истину в последней инстанции, она основывается
на  различной  документации по этим процессорам и моём личном опыте.  Несомненно
существует  масса  других  приёмов  для  оптимизирования программ, я же затронул
самые  основные.   Приступать  к чтению этой статьи можно, имея некоторый опыт в
программировании под эти процессоры.  Хотя и новичкам будет полезно взглянуть на
этот труд, ну профи и так знают всё то, что здесь написано.

 Процессоры  фирмы  Motorola  имеют в наличии кэши команд (68020 и выше), данных
(68030  и  выше),  конвейер (68030 и выше), предвыборка и др., что делает расчёт
времени  выполнения  команд  сложным.   Для того, чтобы понять, какие комбинации
дают большую скорость выполнения, необходимо придерживаться нескольких правил:

 1.   Выборка процессором команд из кэша МНОГО бстрее нежели чем из памяти.  Так
же и с данными (если на процессоре установлен кэш данных - 68030 и выше).

 2.   Команды.   расположенные  по  адресам,  кратным четырём, будут выполняться
одновремменно (правильно сказать команды выровненные по границе длинного слова).
Для  68020  выполнится  одновременно  максимум две последовательные команды т.к.
процессор считывает сразу 4 байта (длииное слово).
 2.1 С MC68030 появляется конвейер, который позволяет выполнить одновременно три
последовательные  команды,  размером  2  байта,  либо  три  слова одной команды.
Конвейер 68060 позволяет выполнить сразу 4 команды.

 3.   Как  можно  меньше  нагружайте  память.   Т.е.   во  времякритичных циклах
программы  все переменные желательно разместить в регистрах, а не запрашивать их
из  памяти.   Здесь также важно заметить, что запись в память быстрее считывания
из неё.

 4.   В программах старайтесь пользоваться котороткими переходами (bne.s, beq.s,
и  т.п.).   При  возможности  старайтесь  загружать  регистры  способами быстрой
загрузки (команды moveq) - эти короткие команды размером одно слово (2 байта).

 5.   Категорически не рекомендуется использовать заранее подготовленные большие
таблицы  в  памяти  (свыше  4-8 кб) и применения больших расцикливаний (убирание
операторов  цикла).   Этот  способ даёт выигрыш на 68000, а вот на более старших
моделях процессоров прирост в скорости будет незначительным.

 6.  Как можно реже пользуйтесь командами деления и умножения (divs, divu, muls,
mulu  и  т.п.)  это  очень  медленные  команды,  а  часть  этих  команд  и вовсе
отсутствует  в  68060 (применяется программная эмуляция).  Применять эти команды
во   времякритичных   циклах  категоричеки  не  рекомендуется,  это  существенно
замедляет выполнение программы.

 7.   Для  переброски большого количества данных можно применять команды move16,
они появились начиная с процессора 68040.

                    Теперь подробнее по каждому из пунктов.

 1.  Кэш команд появляется, начиная с процессора MC68020.  Его размер составляет
256  байт.   Кэш  данных  появился  у  процессора  MC68030  и  его размер так же
составляет  256 байт.  У 68040 оба кэша увеличены в размере до 4096 байт.  68060
обладает двумя восьмикилобайтными кэшами (8192).
 Все основные циклы старайтесь уложить в кэш, расчёты, переброски больших блоков
данных, работа с таблицами и т.д.  должны в него укладываться.
 Допускаются расцикливания в пределах <B>кэша</B>.

 Пример:

prtback_loop1
    move.l (a0)+,a1
    add.l d4,a1
    move.l d0,d6
prtback_loop
    rept 20         ;повторить 20 раз
    move.l (a2)+,(a1)+
    endr            ;команду move.l (a2)+,(a1)+
    dbf d6,prtback_loop
    dbf d5,prtback_loop1

 Вот  такой  простой  цикл  занимает  50 байт.  Он легко укладывается в кэш всех
процессоров.  (Все примеры приводяться из реальных программ.  прим.  автора).

 Если  уложить  цикл в кэш физически не получается, то тогда попытайтесь разбить
его  на  несколько  более  мелких  циклов, укладывающихся в кэш.  На этом методе
основаны  конвертеры  chunky  to  planar  для  68020/68030 процессоров, которыми
пользуются все демомейкеры.

 С  кешем  данных  немного  по  другому.   Всё,  что считывается из памяти любым
методом  адресации  попадает  в этот кэш.  Но в этом кэше практически невозможно
разместить  <U>указатели</U>  на блоки данных или же постоянные переменные (если
их много - 100-200 байт).

 Пример:

    move.l #tableaddr1,a0
    move.l #tableperem,a1
    move.l #new,a2
loop1   move.l (a0)+,d2
    move.l (a1)+,d0
    lsr.l #3,d0
    move.l (a1),d3
    move.l (a3),d1
    add.l d1,d0
    move.d0,(a2)+
    dbf d4,loop1

 Данные  из  a0 и a1 будут оказватся в кэше данных и при повторном использовании
считываться оттуда.


 2.   Процессор  за один раз считывает 4 байта (68020), но делает это по адресам
выровненным по длинному слову.  Пример:

    moveq.l #3,d1
    add.l d1,d0

 Если  первая  команда  будет  выровнена  под длинному слову, то процессор сразу
считает две команды и выполнит их, не затрачивая время на вторую команду.
 Следите  за длинной команд, в предвыборку попадают команды размером в два байта.
Выровнять команды можно при помощи мнемоники ассемблера cnop 0,4.

 2.1 Конвеер, появивший в процессоре 68030 позволил выполнять одновременно сразу
три команды длинной в слово, т.е.  этот процессор может считать сразу 6 байт или
3  слова.   А MC68060 может куда больше - этот процессор венец CISC технологии -
может за один такт выполнить сразу 4 команды.
 Пример: 

    add.l d0,d0
    add.l d0,d0
    add.l d0,d0
    add.l d0,d0 ;умножение содержимого d0 на 16.

 Эти четыре команды могут быть выполнены за 1 (!) такт.

 3.    Нагрузка   на   память   в   основных   циклах  должна  быть  минимальной
(считывание/запись   данных  и  переменных).   Лучше  всё  заранее  разложить  в
свободных  регистрах,  по  возможности  укоротить  команды,  сохранять  лучше  в
регистрах, без использования стека (movem).

 Пример сохранения с последующим восстановлением:

loop    move.l d0,d2    ;сохраняем d0 в d2
    add.l (a0)+,d0
    lsr.l #3,d0
    move.l d0,(a1)+
    move.l d2,d0    ;восстанавливаем
    dbf d3,loop

 Пример укорачивания:

    move.l #80,a5   ;заранее загружаем a5 числом
c2f11   rept 2*step
    movem.l (a0)+,d0-d4/d6-d7/a2-a4 ;read 40 byte
    movem.l d0-d4/d6-d7/a2-a4,-(a1) ;write 40 byte
    add.l a5,a1         ;укорачивание
    endr
    dbf d5,c2f11

 Если  в  этом  случае в a1 складывать с числом (#80), то вместо 2х байт команда
займёт  шесть  и  кроме  более  медленного  исполнения,  ни  о каком паралельном
выполнении не может быть и речи.

 4.   Короткие  переходы  (bcc.s, где cc одно из условий) занимают два байта.  И
естественно  они  вполняються  быстро.   Но,  как говорится, бесплатный сыр есть
только  в  мышеловке.  Это всё достигается за счёт того, что дальность переходов
составляет  128  байт  (назад  или  вперёд).  И связи с этим ваш цикл необходимо
укладывать в 128 байт.
 Вообще  за  командами  перехода надо следить внимательно:  они отнимают времени
больше  обычного  т.к.   приходиться переходить на новый адрес.  Поэтому данному
фактору  надо уделить особое внимание.  Если не получается использовать короткие
переходы,  применяйте  команды  dbf,  они  одновременно совмещают в себе команды
перехода  и уменьшения любого из регистров d0-d7 и могут выполнять более дальние
переходами, хоть и занимают в памяти 4 байта.

 4.1  Для  быстой  загрузки  регистров  применяйте  команды  moveq,  эти команды
способны  загрузить  в  регистр число от 0 до 8ми, причём они занимают всего два
байта  и  выполняются  быстрее  обычной загрузки (move).  Кроме быстрой загрузки
есть   быстрое   сложение  (addq)  и  вычитание  (subq),  которые  имеют  те  же
характеристики, что и moveq (2 байта, диапазон чисел от 0 до 8ми).

 5.   Использовать  большие  таблицы  и  расцикливания НЕ РЕКОМЕНДУЕТСЯ !  Лучше
произвести  все расчёты в основном цикле, хорошо его прооптимизировав, и уложить
в  кэш,  минимизировав  обращения  к  памяти.   Это  естественно  касается  всех
процессоров,  имеющих  кэш.   Как  уже  писалось, кэш-память значительно быстрее
внешней  памяти,  причём  скорость внешней памяти в целом не зависит от скорости
процессора.   А  значит  убирать операторы цикла нецелесообразно.  Съэкономив на
этих операторах, программа будет вынуждена работать только во внешней памяти, со
всеми вытекающими.
 Операторы  перед  вполнением  попадают  в  кэш из памяти, и, если переход будет
осуществлён  на  команду,  которая  находится  в  кэше, то далее весь цикл будет
выполняться из кэша.
 То же и с большими таблицами, выборка данных из памяти ограничена её скоростью.
Т.е.   произведя  заранее  все  расчёты  и  считывая  данные из памяти вы будете
ограничены скоростью памяти.  А если вы хорошо прооптимизируете расчёты, уложите
в  кэш,  то на более быстродействующим процессоре прирост в скорости будет более
значительным.
 Эти  сопособы  были  эффективны на 68000 и если уж надо выжать из машины с этим
процессором всё возможное, делайте отдельную версию.
 Ещё  момент  -  <B>не  применяйте  самомодификацию  кода</B>  !   Раньше многие
демомейкеры  грешили  изменением  участков  кода программы самой программой, это
давало  прирост  в скорости для 68000, а вот для процессоров с кэшем этот подход
запрещён.   Если  такой  участок кода окажется в кэше и начнёт выполняться, то в
самом  кэше НИКАКОЙ модификации происходить не будет в силу его особенностей.  А
это  значит,  что  программа  начнёт  работать не как задумывалось!  Последствия
могут быть катастрофическими.

6.   Команды  деления  и  умножения  (divs, divu, muls, mulu и т.п.) выполняются
меделнно,  поэтому для умножения/деления на числа, кратные степеням двойки можно
применить   операторы  lsr  (деление),  lsl  или  просто  команды  сложения  для
умножения.

 Примеры:

  Для умножения на 16 можно применить 4 сложения.

    add.l d0,d0 ;на 2
    add.l d0,d0 ;на 4
    add.l d0,d0 ;на 8
    add.l d0,d0 ;на 16

  Это же можно проделать одной командой lsl.

    lsl.l #4,d0

 Скорость выполнения этого оператора зависит от числа сдвигаемых битов, т.е.  ко
времени  вполнения  команды надо будет добавить ещё и кол-во смещаемых бит.  И в
некоторых случаях этот вариант может оказаться медленнее предыдущего.

   А что  делалть  если  надо умножить к примеру на 12 ?  Спросить дотошный
читатель. А вот, что:

    move.l d0,d1 ;сохраняем d0 в d1
    add.l d0,d0 ;умножаем на 2
    add.l d1,d0 ;а вот так мы получаем умножение на 3 !
    add.l d0,d0 ;далее умножение на 6
    add.l d0,d0 ;и наконец на 12

 Деление можно осуществить с помощью команды lsr. Например lsr.l #2,d0, даёт
деление на 4, а lsr.l #4,d0 даёт деление на 16ть.

 6.1   В   MC68060  для  увеличения  производительности  были  убраны  некоторые
целочисленные  команды для того, чтобы поднять общую производительность.Для этих
команд  существует  программная  эмуляция  (68060.library).   А  это значит, что
применять  эти  команды  не рекомендуется т.к.  эмуляция в любом случае медленее
непосредственного выполнения.  Вот эти команды:

divu.l <ea>,Dr:Dq ;где Dr,Dq регистр из диапазона D0-D7
divs.l <ea>,Dr:Dq ;---'---
mulu.l <ea>,Dr:Dq ;---'---
muls.l <ea>,Dr:Dq ;---'---
movep Dx,(d16,Ay) ;где Dx регистр из диапазона D0-D7, Ay - A0-A7
movep (d16,Ay),Dx ;---'---
chk2 <ea>,Rn      ;где Rn регистр из диапазона A0-A7,D0-D7
cmp2 <ea>,Rn      ;---'---
cas2 Dc1:Dc2,Du1:Du2,(Rn1:Rn2) ;Dc,Du - D0-D7, Rn - D0-D7,A0-A7
cas Dc:Du,<ea>    ;Dc,Du - D0-D7

<ea> - любой из методов адресации.

 7.   В  68040  появились новые команды для переброски данных, способные за один
раз перебросить 16 байт, они дают небольшое ускорение на переброске данных.  Вот
их полный список:

move16  (Ax)+,(Ay)+  
move16  (xxx).l,(An) 
move16  (xxx).l,(An)+
move16  (An),(xxx).l 
move16  (An)+,(xxx).l

где Ax и An любой регистр из диапазона A0-A7

Все  команды  могут  перебрасывать  только  16  байт и только по адресам кратным
16-ти,  на  больших  блоках данных они дают действительно прирост в скорости, но
ограничены данными факторами.  Их можно применять для больших перебросов данных.

 Levitator/team PowerAmiga